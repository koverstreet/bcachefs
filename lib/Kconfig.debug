# SPDX-License-Identifier: GPL-2.0-only
menu "Kernel hacking"

menu "printk and dmesg options"

config PRINTK_TIME
	bool "Show timing information on printks"
	depends on PRINTK
	help
	  Selecting this option causes time stamps of the printk()
	  messages to be added to the output of the syslog() system
	  call and at the console.

	  The timestamp is always recorded internally, and exported
	  to /dev/kmsg. This flag just specifies if the timestamp should
	  be included, not that the timestamp is recorded.

	  The behavior is also controlled by the kernel command line
	  parameter printk.time=1. See Documentation/admin-guide/kernel-parameters.rst

config PRINTK_CALLER
	bool "Show caller information on printks"
	depends on PRINTK
	help
	  Selecting this option causes printk() to add a caller "thread id" (if
	  in task context) or a caller "processor id" (if not in task context)
	  to every message.

	  This option is intended for environments where multiple threads
	  concurrently call printk() for many times, for it is difficult to
	  interpret without knowing where these lines (or sometimes individual
	  line which was divided into multiple lines due to race) came from.

	  Since toggling after boot makes the code racy, currently there is
	  no option to enable/disable at the kernel command line parameter or
	  sysfs interface.

config STACKTRACE_BUILD_ID
	bool "Show build ID information in stacktraces"
	depends on PRINTK
	help
	  Selecting this option adds build ID information for symbols in
	  stacktraces printed with the printk format '%p[SR]b'.

	  This option is intended for distros where debuginfo is not easily
	  accessible but can be downloaded given the build ID of the vmlinux or
	  kernel module where the function is located.

config CONSOLE_LOGLEVEL_DEFAULT
	int "Default console loglevel (1-15)"
	range 1 15
	default "7"
	help
	  Default loglevel to determine what will be printed on the console.

	  Setting a default here is equivalent to passing in loglevel=<x> in
	  the kernel bootargs. loglevel=<x> continues to override whatever
	  value is specified here as well.

	  Note: This does not affect the log level of un-prefixed printk()
	  usage in the kernel. That is controlled by the MESSAGE_LOGLEVEL_DEFAULT
	  option.

config CONSOLE_LOGLEVEL_QUIET
	int "quiet console loglevel (1-15)"
	range 1 15
	default "4"
	help
	  loglevel to use when "quiet" is passed on the kernel commandline.

	  When "quiet" is passed on the kernel commandline this loglevel
	  will be used as the loglevel. IOW passing "quiet" will be the
	  equivalent of passing "loglevel=<CONSOLE_LOGLEVEL_QUIET>"

config MESSAGE_LOGLEVEL_DEFAULT
	int "Default message log level (1-7)"
	range 1 7
	default "4"
	help
	  Default log level for printk statements with no specified priority.

	  This was hard-coded to KERN_WARNING since at least 2.6.10 but folks
	  that are auditing their logs closely may want to set it to a lower
	  priority.

	  Note: This does not affect what message level gets printed on the console
	  by default. To change that, use loglevel=<x> in the kernel bootargs,
	  or pick a different CONSOLE_LOGLEVEL_DEFAULT configuration value.

config BOOT_PRINTK_DELAY
	bool "Delay each boot printk message by N milliseconds"
	depends on DEBUG_KERNEL && PRINTK && GENERIC_CALIBRATE_DELAY
	help
	  This build option allows you to read kernel boot messages
	  by inserting a short delay after each one.  The delay is
	  specified in milliseconds on the kernel command line,
	  using "boot_delay=N".

	  It is likely that you would also need to use "lpj=M" to preset
	  the "loops per jiffy" value.
	  See a previous boot log for the "lpj" value to use for your
	  system, and then set "lpj=M" before setting "boot_delay=N".
	  NOTE:  Using this option may adversely affect SMP systems.
	  I.e., processors other than the first one may not boot up.
	  BOOT_PRINTK_DELAY also may cause LOCKUP_DETECTOR to detect
	  what it believes to be lockup conditions.

config DYNAMIC_DEBUG
	bool "Enable dynamic printk() support"
	default n
	depends on PRINTK
	depends on (DEBUG_FS || PROC_FS)
	select DYNAMIC_DEBUG_CORE
	help

	  Compiles debug level messages into the kernel, which would not
	  otherwise be available at runtime. These messages can then be
	  enabled/disabled based on various levels of scope - per source file,
	  function, module, format string, and line number. This mechanism
	  implicitly compiles in all pr_debug() and dev_dbg() calls, which
	  enlarges the kernel text size by about 2%.

	  If a source file is compiled with DEBUG flag set, any
	  pr_debug() calls in it are enabled by default, but can be
	  disabled at runtime as below.  Note that DEBUG flag is
	  turned on by many CONFIG_*DEBUG* options.

	  Usage:

	  Dynamic debugging is controlled via the 'dynamic_debug/control' file,
	  which is contained in the 'debugfs' filesystem or procfs.
	  Thus, the debugfs or procfs filesystem must first be mounted before
	  making use of this feature.
	  We refer the control file as: <debugfs>/dynamic_debug/control. This
	  file contains a list of the debug statements that can be enabled. The
	  format for each line of the file is:

		filename:lineno [module]function flags format

	  filename : source file of the debug statement
	  lineno : line number of the debug statement
	  module : module that contains the debug statement
	  function : function that contains the debug statement
	  flags : '=p' means the line is turned 'on' for printing
	  format : the format used for the debug statement

	  From a live system:

		nullarbor:~ # cat <debugfs>/dynamic_debug/control
		# filename:lineno [module]function flags format
		fs/aio.c:222 [aio]__put_ioctx =_ "__put_ioctx:\040freeing\040%p\012"
		fs/aio.c:248 [aio]ioctx_alloc =_ "ENOMEM:\040nr_events\040too\040high\012"
		fs/aio.c:1770 [aio]sys_io_cancel =_ "calling\040cancel\012"

	  Example usage:

		// enable the message at line 1603 of file svcsock.c
		nullarbor:~ # echo -n 'file svcsock.c line 1603 +p' >
						<debugfs>/dynamic_debug/control

		// enable all the messages in file svcsock.c
		nullarbor:~ # echo -n 'file svcsock.c +p' >
						<debugfs>/dynamic_debug/control

		// enable all the messages in the NFS server module
		nullarbor:~ # echo -n 'module nfsd +p' >
						<debugfs>/dynamic_debug/control

		// enable all 12 messages in the function svc_process()
		nullarbor:~ # echo -n 'func svc_process +p' >
						<debugfs>/dynamic_debug/control

		// disable all 12 messages in the function svc_process()
		nullarbor:~ # echo -n 'func svc_process -p' >
						<debugfs>/dynamic_debug/control

	  See Documentation/admin-guide/dynamic-debug-howto.rst for additional
	  information.

config DYNAMIC_DEBUG_CORE
	bool "Enable core function of dynamic debug support"
	depends on PRINTK
	depends on (DEBUG_FS || PROC_FS)
	help
	  Enable core functional support of dynamic debug. It is useful
	  when you want to tie dynamic debug to your kernel modules with
	  DYNAMIC_DEBUG_MODULE defined for each of them, especially for
	  the case of embedded system where the kernel image size is
	  sensitive for people.

config SYMBOLIC_ERRNAME
	bool "Support symbolic error names in printf"
	default y if PRINTK
	help
	  If you say Y here, the kernel's printf implementation will
	  be able to print symbolic error names such as ENOSPC instead
	  of the number 28. It makes the kernel image slightly larger
	  (about 3KB), but can make the kernel logs easier to read.

config DEBUG_BUGVERBOSE
	bool "Verbose BUG() reporting (adds 70K)" if DEBUG_KERNEL && EXPERT
	depends on BUG && (GENERIC_BUG || HAVE_DEBUG_BUGVERBOSE)
	default y
	help
	  Say Y here to make BUG() panics output the file name and line number
	  of the BUG call as well as the EIP and oops trace.  This aids
	  debugging but costs about 70-100K of memory.

endmenu # "printk and dmesg options"

config DEBUG_KERNEL
	bool "Kernel debugging"
	help
	  Say Y here if you are developing drivers or trying to debug and
	  identify kernel problems.

config DEBUG_MISC
	bool "Miscellaneous debug code"
	default DEBUG_KERNEL
	depends on DEBUG_KERNEL
	help
	  Say Y here if you need to enable miscellaneous debug code that should
	  be under a more specific debug option but isn't.

menu "Compile-time checks and compiler options"

config DEBUG_INFO
	bool
	help
	  A kernel debug info option other than "None" has been selected
	  in the "Debug information" choice below, indicating that debug
	  information will be generated for build targets.

# Clang generates .uleb128 with label differences for DWARF v5, a feature that
# older binutils ports do not support when utilizing RISC-V style linker
# relaxation: https://sourceware.org/bugzilla/show_bug.cgi?id=27215
config AS_HAS_NON_CONST_ULEB128
	def_bool $(as-instr,.uleb128 .Lexpr_end4 - .Lexpr_start3\n.Lexpr_start3:\n.Lexpr_end4:)

choice
	prompt "Debug information"
	depends on DEBUG_KERNEL
	help
	  Selecting something other than "None" results in a kernel image
	  that will include debugging info resulting in a larger kernel image.
	  This adds debug symbols to the kernel and modules (gcc -g), and
	  is needed if you intend to use kernel crashdump or binary object
	  tools like crash, kgdb, LKCD, gdb, etc on the kernel.

	  Choose which version of DWARF debug info to emit. If unsure,
	  select "Toolchain default".

config DEBUG_INFO_NONE
	bool "Disable debug information"
	help
	  Do not build the kernel with debugging information, which will
	  result in a faster and smaller build.

config DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT
	bool "Rely on the toolchain's implicit default DWARF version"
	select DEBUG_INFO
	depends on !CC_IS_CLANG || AS_IS_LLVM || CLANG_VERSION < 140000 || (AS_IS_GNU && AS_VERSION >= 23502 && AS_HAS_NON_CONST_ULEB128)
	help
	  The implicit default version of DWARF debug info produced by a
	  toolchain changes over time.

	  This can break consumers of the debug info that haven't upgraded to
	  support newer revisions, and prevent testing newer versions, but
	  those should be less common scenarios.

config DEBUG_INFO_DWARF4
	bool "Generate DWARF Version 4 debuginfo"
	select DEBUG_INFO
	depends on !CC_IS_CLANG || AS_IS_LLVM || (AS_IS_GNU && AS_VERSION >= 23502)
	help
	  Generate DWARF v4 debug info. This requires gcc 4.5+, binutils 2.35.2
	  if using clang without clang's integrated assembler, and gdb 7.0+.

	  If you have consumers of DWARF debug info that are not ready for
	  newer revisions of DWARF, you may wish to choose this or have your
	  config select this.

config DEBUG_INFO_DWARF5
	bool "Generate DWARF Version 5 debuginfo"
	select DEBUG_INFO
	depends on !ARCH_HAS_BROKEN_DWARF5
	depends on !CC_IS_CLANG || AS_IS_LLVM || (AS_IS_GNU && AS_VERSION >= 23502 && AS_HAS_NON_CONST_ULEB128)
	help
	  Generate DWARF v5 debug info. Requires binutils 2.35.2, gcc 5.0+ (gcc
	  5.0+ accepts the -gdwarf-5 flag but only had partial support for some
	  draft features until 7.0), and gdb 8.0+.

	  Changes to the structure of debug info in Version 5 allow for around
	  15-18% savings in resulting image and debug info section sizes as
	  compared to DWARF Version 4. DWARF Version 5 standardizes previous
	  extensions such as accelerators for symbol indexing and the format
	  for fission (.dwo/.dwp) files. Users may not want to select this
	  config if they rely on tooling that has not yet been updated to
	  support DWARF Version 5.

endchoice # "Debug information"

if DEBUG_INFO

config DEBUG_INFO_REDUCED
	bool "Reduce debugging information"
	help
	  If you say Y here gcc is instructed to generate less debugging
	  information for structure types. This means that tools that
	  need full debugging information (like kgdb or systemtap) won't
	  be happy. But if you merely need debugging information to
	  resolve line numbers there is no loss. Advantage is that
	  build directory object sizes shrink dramatically over a full
	  DEBUG_INFO build and compile times are reduced too.
	  Only works with newer gcc versions.

choice
	prompt "Compressed Debug information"
	help
	  Compress the resulting debug info. Results in smaller debug info sections,
	  but requires that consumers are able to decompress the results.

	  If unsure, choose DEBUG_INFO_COMPRESSED_NONE.

config DEBUG_INFO_COMPRESSED_NONE
	bool "Don't compress debug information"
	help
	  Don't compress debug info sections.

config DEBUG_INFO_COMPRESSED_ZLIB
	bool "Compress debugging information with zlib"
	depends on $(cc-option,-gz=zlib)
	depends on $(ld-option,--compress-debug-sections=zlib)
	help
	  Compress the debug information using zlib.  Requires GCC 5.0+ or Clang
	  5.0+, binutils 2.26+, and zlib.

	  Users of dpkg-deb via debian/rules may find an increase in
	  size of their debug .deb packages with this config set, due to the
	  debug info being compressed with zlib, then the object files being
	  recompressed with a different compression scheme. But this is still
	  preferable to setting KDEB_COMPRESS or DPKG_DEB_COMPRESSOR_TYPE to
	  "none" which would be even larger.

config DEBUG_INFO_COMPRESSED_ZSTD
	bool "Compress debugging information with zstd"
	depends on $(cc-option,-gz=zstd)
	depends on $(ld-option,--compress-debug-sections=zstd)
	help
	  Compress the debug information using zstd.  This may provide better
	  compression than zlib, for about the same time costs, but requires newer
	  toolchain support.  Requires GCC 13.0+ or Clang 16.0+, binutils 2.40+, and
	  zstd.

endchoice # "Compressed Debug information"

config DEBUG_INFO_SPLIT
	bool "Produce split debuginfo in .dwo files"
	depends on $(cc-option,-gsplit-dwarf)
	# RISC-V linker relaxation + -gsplit-dwarf has issues with LLVM and GCC
	# prior to 12.x:
	# https://github.com/llvm/llvm-project/issues/56642
	# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99090
	depends on !RISCV || GCC_VERSION >= 120000
	help
	  Generate debug info into separate .dwo files. This significantly
	  reduces the build directory size for builds with DEBUG_INFO,
	  because it stores the information only once on disk in .dwo
	  files instead of multiple times in object files and executables.
	  In addition the debug information is also compressed.

	  Requires recent gcc (4.7+) and recent gdb/binutils.
	  Any tool that packages or reads debug information would need
	  to know about the .dwo files and include them.
	  Incompatible with older versions of ccache.

config DEBUG_INFO_BTF
	bool "Generate BTF type information"
	depends on !DEBUG_INFO_SPLIT && !DEBUG_INFO_REDUCED
	depends on !GCC_PLUGIN_RANDSTRUCT || COMPILE_TEST
	depends on BPF_SYSCALL
	depends on PAHOLE_VERSION >= 116
	depends on DEBUG_INFO_DWARF4 || PAHOLE_VERSION >= 121
	# pahole uses elfutils, which does not have support for Hexagon relocations
	depends on !HEXAGON
	help
	  Generate deduplicated BTF type information from DWARF debug info.
	  Turning this on requires pahole v1.16 or later (v1.21 or later to
	  support DWARF 5), which will convert DWARF type info into equivalent
	  deduplicated BTF type info.

config PAHOLE_HAS_SPLIT_BTF
	def_bool PAHOLE_VERSION >= 119

config PAHOLE_HAS_BTF_TAG
	def_bool PAHOLE_VERSION >= 123
	depends on CC_IS_CLANG
	help
	  Decide whether pahole emits btf_tag attributes (btf_type_tag and
	  btf_decl_tag) or not. Currently only clang compiler implements
	  these attributes, so make the config depend on CC_IS_CLANG.

config PAHOLE_HAS_LANG_EXCLUDE
	def_bool PAHOLE_VERSION >= 124
	help
	  Support for the --lang_exclude flag which makes pahole exclude
	  compilation units from the supplied language. Used in Kbuild to
	  omit Rust CUs which are not supported in version 1.24 of pahole,
	  otherwise it would emit malformed kernel and module binaries when
	  using DEBUG_INFO_BTF_MODULES.

config DEBUG_INFO_BTF_MODULES
	bool "Generate BTF type information for kernel modules"
	default y
	depends on DEBUG_INFO_BTF && MODULES && PAHOLE_HAS_SPLIT_BTF
	help
	  Generate compact split BTF type information for kernel modules.

config MODULE_ALLOW_BTF_MISMATCH
	bool "Allow loading modules with non-matching BTF type info"
	depends on DEBUG_INFO_BTF_MODULES
	help
	  For modules whose split BTF does not match vmlinux, load without
	  BTF rather than refusing to load. The default behavior with
	  module BTF enabled is to reject modules with such mismatches;
	  this option will still load module BTF where possible but ignore
	  it when a mismatch is found.

config GDB_SCRIPTS
	bool "Provide GDB scripts for kernel debugging"
	help
	  This creates the required links to GDB helper scripts in the
	  build directory. If you load vmlinux into gdb, the helper
	  scripts will be automatically imported by gdb as well, and
	  additional functions are available to analyze a Linux kernel
	  instance. See Documentation/process/debugging/gdb-kernel-debugging.rst
	  for further details.

endif # DEBUG_INFO

config FRAME_WARN
	int "Warn for stack frames larger than"
	range 0 8192
	default 0 if KMSAN
	default 2048 if GCC_PLUGIN_LATENT_ENTROPY
	default 2048 if PARISC
	default 1536 if (!64BIT && XTENSA)
	default 1280 if KASAN && !64BIT
	default 1024 if !64BIT
	default 2048 if 64BIT
	help
	  Tell the compiler to warn at build time for stack frames larger than this.
	  Setting this too low will cause a lot of warnings.
	  Setting it to 0 disables the warning.

config STRIP_ASM_SYMS
	bool "Strip assembler-generated symbols during link"
	default n
	help
	  Strip internal assembler-generated symbols during a link (symbols
	  that look like '.Lxxx') so they don't pollute the output of
	  get_wchan() and suchlike.

config READABLE_ASM
	bool "Generate readable assembler code"
	depends on DEBUG_KERNEL
	depends on CC_IS_GCC
	help
	  Disable some compiler optimizations that tend to generate human unreadable
	  assembler output. This may make the kernel slightly slower, but it helps
	  to keep kernel developers who have to stare a lot at assembler listings
	  sane.

config HEADERS_INSTALL
	bool "Install uapi headers to usr/include"
	help
	  This option will install uapi headers (headers exported to user-space)
	  into the usr/include directory for use during the kernel build.
	  This is unneeded for building the kernel itself, but needed for some
	  user-space program samples. It is also needed by some features such
	  as uapi header sanity checks.

config DEBUG_SECTION_MISMATCH
	bool "Enable full Section mismatch analysis"
	depends on CC_IS_GCC
	help
	  The section mismatch analysis checks if there are illegal
	  references from one section to another section.
	  During linktime or runtime, some sections are dropped;
	  any use of code/data previously in these sections would
	  most likely result in an oops.
	  In the code, functions and variables are annotated with
	  __init,, etc. (see the full list in include/linux/init.h),
	  which results in the code/data being placed in specific sections.
	  The section mismatch analysis is always performed after a full
	  kernel build, and enabling this option causes the following
	  additional step to occur:
	  - Add the option -fno-inline-functions-called-once to gcc commands.
	    When inlining a function annotated with __init in a non-init
	    function, we would lose the section information and thus
	    the analysis would not catch the illegal reference.
	    This option tells gcc to inline less (but it does result in
	    a larger kernel).

config SECTION_MISMATCH_WARN_ONLY
	bool "Make section mismatch errors non-fatal"
	default y
	help
	  If you say N here, the build process will fail if there are any
	  section mismatch, instead of just throwing warnings.

	  If unsure, say Y.

config DEBUG_FORCE_FUNCTION_ALIGN_64B
	bool "Force all function address 64B aligned"
	depends on EXPERT && (X86_64 || ARM64 || PPC32 || PPC64 || ARC || RISCV || S390)
	select FUNCTION_ALIGNMENT_64B
	help
	  There are cases that a commit from one domain changes the function
	  address alignment of other domains, and cause magic performance
	  bump (regression or improvement). Enable this option will help to
	  verify if the bump is caused by function alignment changes, while
	  it will slightly increase the kernel size and affect icache usage.

	  It is mainly for debug and performance tuning use.

#
# Select this config option from the architecture Kconfig, if it
# is preferred to always offer frame pointers as a config
# option on the architecture (regardless of KERNEL_DEBUG):
#
config ARCH_WANT_FRAME_POINTERS
	bool

config FRAME_POINTER
	bool "Compile the kernel with frame pointers"
	depends on DEBUG_KERNEL && (M68K || UML || SUPERH) || ARCH_WANT_FRAME_POINTERS
	default y if (DEBUG_INFO && UML) || ARCH_WANT_FRAME_POINTERS
	help
	  If you say Y here the resulting kernel image will be slightly
	  larger and slower, but it gives very useful debugging information
	  in case of kernel bugs. (precise oopses/stacktraces/warnings)

config OBJTOOL
	bool

config OBJTOOL_WERROR
	bool "Upgrade objtool warnings to errors"
	depends on OBJTOOL && !COMPILE_TEST
	help
	  Fail the build on objtool warnings.

	  Objtool warnings can indicate kernel instability, including boot
	  failures.  This option is highly recommended.

	  If unsure, say Y.

config STACK_VALIDATION
	bool "Compile-time stack metadata validation"
	depends on HAVE_STACK_VALIDATION && UNWINDER_FRAME_POINTER
	select OBJTOOL
	default n
	help
	  Validate frame pointer rules at compile-time.  This helps ensure that
	  runtime stack traces are more reliable.

	  For more information, see
	  tools/objtool/Documentation/objtool.txt.

config NOINSTR_VALIDATION
	bool
	depends on HAVE_NOINSTR_VALIDATION && DEBUG_ENTRY
	select OBJTOOL
	default y

config VMLINUX_MAP
	bool "Generate vmlinux.map file when linking"
	depends on EXPERT
	help
	  Selecting this option will pass "-Map=vmlinux.map" to ld
	  when linking vmlinux. That file can be useful for verifying
	  and debugging magic section games, and for seeing which
	  pieces of code get eliminated with
	  CONFIG_LD_DEAD_CODE_DATA_ELIMINATION.

config BUILTIN_MODULE_RANGES
	bool "Generate address range information for builtin modules"
	depends on !LTO
	depends on VMLINUX_MAP
	help
	 When modules are built into the kernel, there will be no module name
	 associated with its symbols in /proc/kallsyms.  Tracers may want to
	 identify symbols by module name and symbol name regardless of whether
	 the module is configured as loadable or not.

	 This option generates modules.builtin.ranges in the build tree with
	 offset ranges (per ELF section) for the module(s) they belong to.
	 It also records an anchor symbol to determine the load address of the
	 section.

config DEBUG_FORCE_WEAK_PER_CPU
	bool "Force weak per-cpu definitions"
	depends on DEBUG_KERNEL
	help
	  s390 and alpha require percpu variables in modules to be
	  defined weak to work around addressing range issue which
	  puts the following two restrictions on percpu variable
	  definitions.

	  1. percpu symbols must be unique whether static or not
	  2. percpu variables can't be defined inside a function

	  To ensure that generic code follows the above rules, this
	  option forces all percpu variables to be defined as weak.

endmenu # "Compiler options"

menu "Generic Kernel Debugging Instruments"

config MAGIC_SYSRQ
	bool "Magic SysRq key"
	depends on !UML
	help
	  If you say Y here, you will have some control over the system even
	  if the system crashes for example during kernel debugging (e.g., you
	  will be able to flush the buffer cache to disk, reboot the system
	  immediately or dump some status information). This is accomplished
	  by pressing various keys while holding SysRq (Alt+PrintScreen). It
	  also works on a serial console (on PC hardware at least), if you
	  send a BREAK and then within 5 seconds a command keypress. The
	  keys are documented in <file:Documentation/admin-guide/sysrq.rst>.
	  Don't say Y unless you really know what this hack does.

config MAGIC_SYSRQ_DEFAULT_ENABLE
	hex "Enable magic SysRq key functions by default"
	depends on MAGIC_SYSRQ
	default 0x1
	help
	  Specifies which SysRq key functions are enabled by default.
	  This may be set to 1 or 0 to enable or disable them all, or
	  to a bitmask as described in Documentation/admin-guide/sysrq.rst.

config MAGIC_SYSRQ_SERIAL
	bool "Enable magic SysRq key over serial"
	depends on MAGIC_SYSRQ
	default y
	help
	  Many embedded boards have a disconnected TTL level serial which can
	  generate some garbage that can lead to spurious false sysrq detects.
	  This option allows you to decide whether you want to enable the
	  magic SysRq key.

config MAGIC_SYSRQ_SERIAL_SEQUENCE
	string "Char sequence that enables magic SysRq over serial"
	depends on MAGIC_SYSRQ_SERIAL
	default ""
	help
	  Specifies a sequence of characters that can follow BREAK to enable
	  SysRq on a serial console.

	  If unsure, leave an empty string and the option will not be enabled.

config DEBUG_FS
	bool "Debug Filesystem"
	help
	  debugfs is a virtual file system that kernel developers use to put
	  debugging files into.  Enable this option to be able to read and
	  write to these files.

	  For detailed documentation on the debugfs API, see
	  Documentation/filesystems/.

	  If unsure, say N.

choice
	prompt "Debugfs default access"
	depends on DEBUG_FS
	default DEBUG_FS_ALLOW_ALL
	help
	  This selects the default access restrictions for debugfs.
	  It can be overridden with kernel command line option
	  debugfs=[on,no-mount,off]. The restrictions apply for API access
	  and filesystem registration.

config DEBUG_FS_ALLOW_ALL
	bool "Access normal"
	help
	  No restrictions apply. Both API and filesystem registration
	  is on. This is the normal default operation.

config DEBUG_FS_DISALLOW_MOUNT
	bool "Do not register debugfs as filesystem"
	help
	  The API is open but filesystem is not loaded. Clients can still do
	  their work and read with debug tools that do not need
	  debugfs filesystem.

config DEBUG_FS_ALLOW_NONE
	bool "No access"
	help
	  Access is off. Clients get -PERM when trying to create nodes in
	  debugfs tree and debugfs is not registered as a filesystem.
	  Client can then back-off or continue without debugfs access.

endchoice

source "lib/Kconfig.kgdb"
source "lib/Kconfig.ubsan"
source "lib/Kconfig.kcsan"

endmenu

menu "Networking Debugging"

source "net/Kconfig.debug"

endmenu # "Networking Debugging"

menu "Memory Debugging"

source "mm/Kconfig.debug"

config DEBUG_OBJECTS
	bool "Debug object operations"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, additional code will be inserted into the
	  kernel to track the life time of various objects and validate
	  the operations on those objects.

config DEBUG_OBJECTS_SELFTEST
	bool "Debug objects selftest"
	depends on DEBUG_OBJECTS
	help
	  This enables the selftest of the object debug code.

config DEBUG_OBJECTS_FREE
	bool "Debug objects in freed memory"
	depends on DEBUG_OBJECTS
	help
	  This enables checks whether a k/v free operation frees an area
	  which contains an object which has not been deactivated
	  properly. This can make kmalloc/kfree-intensive workloads
	  much slower.

config DEBUG_OBJECTS_TIMERS
	bool "Debug timer objects"
	depends on DEBUG_OBJECTS
	help
	  If you say Y here, additional code will be inserted into the
	  timer routines to track the life time of timer objects and
	  validate the timer operations.

config DEBUG_OBJECTS_WORK
	bool "Debug work objects"
	depends on DEBUG_OBJECTS
	help
	  If you say Y here, additional code will be inserted into the
	  work queue routines to track the life time of work objects and
	  validate the work operations.

config DEBUG_OBJECTS_RCU_HEAD
	bool "Debug RCU callbacks objects"
	depends on DEBUG_OBJECTS
	help
	  Enable this to turn on debugging of RCU list heads (call_rcu() usage).

config DEBUG_OBJECTS_PERCPU_COUNTER
	bool "Debug percpu counter objects"
	depends on DEBUG_OBJECTS
	help
	  If you say Y here, additional code will be inserted into the
	  percpu counter routines to track the life time of percpu counter
	  objects and validate the percpu counter operations.

config DEBUG_OBJECTS_ENABLE_DEFAULT
	int "debug_objects bootup default value (0-1)"
	range 0 1
	default "1"
	depends on DEBUG_OBJECTS
	help
	  Debug objects boot parameter default value

config SHRINKER_DEBUG
	bool "Enable shrinker debugging support"
	depends on DEBUG_FS
	help
	  Say Y to enable the shrinker debugfs interface which provides
	  visibility into the kernel memory shrinkers subsystem.
	  Disable it to avoid an extra memory footprint.

config DEBUG_STACK_USAGE
	bool "Stack utilization instrumentation"
	depends on DEBUG_KERNEL
	help
	  Enables the display of the minimum amount of free stack which each
	  task has ever had available in the sysrq-T and sysrq-P debug output.
	  Also emits a message to dmesg when a process exits if that process
	  used more stack space than previously exiting processes.

	  This option will slow down process creation somewhat.

config SCHED_STACK_END_CHECK
	bool "Detect stack corruption on calls to schedule()"
	depends on DEBUG_KERNEL
	default n
	help
	  This option checks for a stack overrun on calls to schedule().
	  If the stack end location is found to be over written always panic as
	  the content of the corrupted region can no longer be trusted.
	  This is to ensure no erroneous behaviour occurs which could result in
	  data corruption or a sporadic crash at a later stage once the region
	  is examined. The runtime overhead introduced is minimal.

config ARCH_HAS_DEBUG_VM_PGTABLE
	bool
	help
	  An architecture should select this when it can successfully
	  build and run DEBUG_VM_PGTABLE.

config DEBUG_VFS
	bool "Debug VFS"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on extended checks in the VFS layer that may impact
	  performance.

	  If unsure, say N.

config DEBUG_VM_IRQSOFF
	def_bool DEBUG_VM && !PREEMPT_RT

config DEBUG_VM
	bool "Debug VM"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on extended checks in the virtual-memory system
	  that may impact performance.

	  If unsure, say N.

config DEBUG_VM_SHOOT_LAZIES
	bool "Debug MMU_LAZY_TLB_SHOOTDOWN implementation"
	depends on DEBUG_VM
	depends on MMU_LAZY_TLB_SHOOTDOWN
	help
	  Enable additional IPIs that ensure lazy tlb mm references are removed
	  before the mm is freed.

	  If unsure, say N.

config DEBUG_VM_MAPLE_TREE
	bool "Debug VM maple trees"
	depends on DEBUG_VM
	select DEBUG_MAPLE_TREE
	help
	  Enable VM maple tree debugging information and extra validations.

	  If unsure, say N.

config DEBUG_VM_RB
	bool "Debug VM red-black trees"
	depends on DEBUG_VM
	help
	  Enable VM red-black tree debugging information and extra validations.

	  If unsure, say N.

config DEBUG_VM_PGFLAGS
	bool "Debug page-flags operations"
	depends on DEBUG_VM
	help
	  Enables extra validation on page flags operations.

	  If unsure, say N.

config DEBUG_VM_PGTABLE
	bool "Debug arch page table for semantics compliance"
	depends on MMU
	depends on ARCH_HAS_DEBUG_VM_PGTABLE
	default y if DEBUG_VM
	help
	  This option provides a debug method which can be used to test
	  architecture page table helper functions on various platforms in
	  verifying if they comply with expected generic MM semantics. This
	  will help architecture code in making sure that any changes or
	  new additions of these helpers still conform to expected
	  semantics of the generic MM. Platforms will have to opt in for
	  this through ARCH_HAS_DEBUG_VM_PGTABLE.

	  If unsure, say N.

config ARCH_HAS_DEBUG_VIRTUAL
	bool

config DEBUG_VIRTUAL
	bool "Debug VM translations"
	depends on DEBUG_KERNEL && ARCH_HAS_DEBUG_VIRTUAL
	help
	  Enable some costly sanity checks in virtual to page code. This can
	  catch mistakes with virt_to_page() and friends.

	  If unsure, say N.

config DEBUG_NOMMU_REGIONS
	bool "Debug the global anon/private NOMMU mapping region tree"
	depends on DEBUG_KERNEL && !MMU
	help
	  This option causes the global tree of anonymous and private mapping
	  regions to be regularly checked for invalid topology.

config DEBUG_MEMORY_INIT
	bool "Debug memory initialisation" if EXPERT
	default !EXPERT
	help
	  Enable this for additional checks during memory initialisation.
	  The sanity checks verify aspects of the VM such as the memory model
	  and other information provided by the architecture. Verbose
	  information will be printed at KERN_DEBUG loglevel depending
	  on the mminit_loglevel= command-line option.

	  If unsure, say Y

config MEMORY_NOTIFIER_ERROR_INJECT
	tristate "Memory hotplug notifier error injection module"
	depends on MEMORY_HOTPLUG && NOTIFIER_ERROR_INJECTION
	help
	  This option provides the ability to inject artificial errors to
	  memory hotplug notifier chain callbacks.  It is controlled through
	  debugfs interface under /sys/kernel/debug/notifier-error-inject/memory

	  If the notifier call chain should be failed with some events
	  notified, write the error code to "actions/<notifier event>/error".

	  Example: Inject memory hotplug offline error (-12 == -ENOMEM)

	  # cd /sys/kernel/debug/notifier-error-inject/memory
	  # echo -12 > actions/MEM_GOING_OFFLINE/error
	  # echo offline > /sys/devices/system/memory/memoryXXX/state
	  bash: echo: write error: Cannot allocate memory

	  To compile this code as a module, choose M here: the module will
	  be called memory-notifier-error-inject.

	  If unsure, say N.

config DEBUG_PER_CPU_MAPS
	bool "Debug access to per_cpu maps"
	depends on DEBUG_KERNEL
	depends on SMP
	help
	  Say Y to verify that the per_cpu map being accessed has
	  been set up. This adds a fair amount of code to kernel memory
	  and decreases performance.

	  Say N if unsure.

config DEBUG_KMAP_LOCAL
	bool "Debug kmap_local temporary mappings"
	depends on DEBUG_KERNEL && KMAP_LOCAL
	help
	  This option enables additional error checking for the kmap_local
	  infrastructure.  Disable for production use.

config ARCH_SUPPORTS_KMAP_LOCAL_FORCE_MAP
	bool

config DEBUG_KMAP_LOCAL_FORCE_MAP
	bool "Enforce kmap_local temporary mappings"
	depends on DEBUG_KERNEL && ARCH_SUPPORTS_KMAP_LOCAL_FORCE_MAP
	select KMAP_LOCAL
	select DEBUG_KMAP_LOCAL
	help
	  This option enforces temporary mappings through the kmap_local
	  mechanism for non-highmem pages and on non-highmem systems.
	  Disable this for production systems!

config DEBUG_HIGHMEM
	bool "Highmem debugging"
	depends on DEBUG_KERNEL && HIGHMEM
	select DEBUG_KMAP_LOCAL_FORCE_MAP if ARCH_SUPPORTS_KMAP_LOCAL_FORCE_MAP
	select DEBUG_KMAP_LOCAL
	help
	  This option enables additional error checking for high memory
	  systems.  Disable for production systems.

config HAVE_DEBUG_STACKOVERFLOW
	bool

config DEBUG_STACKOVERFLOW
	bool "Check for stack overflows"
	depends on DEBUG_KERNEL && HAVE_DEBUG_STACKOVERFLOW
	help
	  Say Y here if you want to check for overflows of kernel, IRQ
	  and exception stacks (if your architecture uses them). This
	  option will show detailed messages if free stack space drops
	  below a certain limit.

	  These kinds of bugs usually occur when call-chains in the
	  kernel get too deep, especially when interrupts are
	  involved.

	  Use this in cases where you see apparently random memory
	  corruption, especially if it appears in 'struct thread_info'

	  If in doubt, say "N".

config CODE_TAGGING
	bool
	select KALLSYMS

config MEM_ALLOC_PROFILING
	bool "Enable memory allocation profiling"
	default n
	depends on MMU
	depends on PROC_FS
	depends on !DEBUG_FORCE_WEAK_PER_CPU
	select CODE_TAGGING
	select PAGE_EXTENSION
	select SLAB_OBJ_EXT
	help
	  Track allocation source code and record total allocation size
	  initiated at that code location. The mechanism can be used to track
	  memory leaks with a low performance and memory impact.

config MEM_ALLOC_PROFILING_ENABLED_BY_DEFAULT
	bool "Enable memory allocation profiling by default"
	default y
	depends on MEM_ALLOC_PROFILING

config MEM_ALLOC_PROFILING_DEBUG
	bool "Memory allocation profiler debugging"
	default n
	depends on MEM_ALLOC_PROFILING
	select MEM_ALLOC_PROFILING_ENABLED_BY_DEFAULT
	help
	  Adds warnings with helpful error messages for memory allocation
	  profiling.

source "lib/Kconfig.kasan"
source "lib/Kconfig.kfence"
source "lib/Kconfig.kmsan"

endmenu # "Memory Debugging"

config DEBUG_SHIRQ
	bool "Debug shared IRQ handlers"
	depends on DEBUG_KERNEL
	help
	  Enable this to generate a spurious interrupt just before a shared
	  interrupt handler is deregistered (generating one when registering
	  is currently disabled). Drivers need to handle this correctly. Some
	  don't and need to be caught.

menu "Debug Oops, Lockups and Hangs"

config PANIC_ON_OOPS
	bool "Panic on Oops"
	help
	  Say Y here to enable the kernel to panic when it oopses. This
	  has the same effect as setting oops=panic on the kernel command
	  line.

	  This feature is useful to ensure that the kernel does not do
	  anything erroneous after an oops which could result in data
	  corruption or other issues.

	  Say N if unsure.

config PANIC_ON_OOPS_VALUE
	int
	range 0 1
	default 0 if !PANIC_ON_OOPS
	default 1 if PANIC_ON_OOPS

config PANIC_TIMEOUT
	int "panic timeout"
	default 0
	help
	  Set the timeout value (in seconds) until a reboot occurs when
	  the kernel panics. If n = 0, then we wait forever. A timeout
	  value n > 0 will wait n seconds before rebooting, while a timeout
	  value n < 0 will reboot immediately. This setting can be overridden
	  with the kernel command line option panic=, and from userspace via
	  /proc/sys/kernel/panic.

config LOCKUP_DETECTOR
	bool

config SOFTLOCKUP_DETECTOR
	bool "Detect Soft Lockups"
	depends on DEBUG_KERNEL && !S390
	select LOCKUP_DETECTOR
	help
	  Say Y here to enable the kernel to act as a watchdog to detect
	  soft lockups.

	  Softlockups are bugs that cause the kernel to loop in kernel
	  mode for more than 20 seconds, without giving other tasks a
	  chance to run.  The current stack trace is displayed upon
	  detection and the system will stay locked up.

config SOFTLOCKUP_DETECTOR_INTR_STORM
	bool "Detect Interrupt Storm in Soft Lockups"
	depends on SOFTLOCKUP_DETECTOR && IRQ_TIME_ACCOUNTING
	select GENERIC_IRQ_STAT_SNAPSHOT
	default y if NR_CPUS <= 128
	help
	  Say Y here to enable the kernel to detect interrupt storm
	  during "soft lockups".

	  "soft lockups" can be caused by a variety of reasons. If one is
	  caused by an interrupt storm, then the storming interrupts will not
	  be on the callstack. To detect this case, it is necessary to report
	  the CPU stats and the interrupt counts during the "soft lockups".

config BOOTPARAM_SOFTLOCKUP_PANIC
	bool "Panic (Reboot) On Soft Lockups"
	depends on SOFTLOCKUP_DETECTOR
	help
	  Say Y here to enable the kernel to panic on "soft lockups",
	  which are bugs that cause the kernel to loop in kernel
	  mode for more than 20 seconds (configurable using the watchdog_thresh
	  sysctl), without giving other tasks a chance to run.

	  The panic can be used in combination with panic_timeout,
	  to cause the system to reboot automatically after a
	  lockup has been detected. This feature is useful for
	  high-availability systems that have uptime guarantees and
	  where a lockup must be resolved ASAP.

	  Say N if unsure.

config HAVE_HARDLOCKUP_DETECTOR_BUDDY
	bool
	depends on SMP
	default y

#
# Global switch whether to build a hardlockup detector at all. It is available
# only when the architecture supports at least one implementation. There are
# two exceptions. The hardlockup detector is never enabled on:
#
#	s390: it reported many false positives there
#
#	sparc64: has a custom implementation which is not using the common
#		hardlockup command line options and sysctl interface.
#
config HARDLOCKUP_DETECTOR
	bool "Detect Hard Lockups"
	depends on DEBUG_KERNEL && !S390 && !HARDLOCKUP_DETECTOR_SPARC64
	depends on HAVE_HARDLOCKUP_DETECTOR_PERF || HAVE_HARDLOCKUP_DETECTOR_BUDDY || HAVE_HARDLOCKUP_DETECTOR_ARCH
	imply HARDLOCKUP_DETECTOR_PERF
	imply HARDLOCKUP_DETECTOR_BUDDY
	imply HARDLOCKUP_DETECTOR_ARCH
	select LOCKUP_DETECTOR

	help
	  Say Y here to enable the kernel to act as a watchdog to detect
	  hard lockups.

	  Hardlockups are bugs that cause the CPU to loop in kernel mode
	  for more than 10 seconds, without letting other interrupts have a
	  chance to run.  The current stack trace is displayed upon detection
	  and the system will stay locked up.

#
# Note that arch-specific variants are always preferred.
#
config HARDLOCKUP_DETECTOR_PREFER_BUDDY
	bool "Prefer the buddy CPU hardlockup detector"
	depends on HARDLOCKUP_DETECTOR
	depends on HAVE_HARDLOCKUP_DETECTOR_PERF && HAVE_HARDLOCKUP_DETECTOR_BUDDY
	depends on !HAVE_HARDLOCKUP_DETECTOR_ARCH
	help
	  Say Y here to prefer the buddy hardlockup detector over the perf one.

	  With the buddy detector, each CPU uses its softlockup hrtimer
	  to check that the next CPU is processing hrtimer interrupts by
	  verifying that a counter is increasing.

	  This hardlockup detector is useful on systems that don't have
	  an arch-specific hardlockup detector or if resources needed
	  for the hardlockup detector are better used for other things.

config HARDLOCKUP_DETECTOR_PERF
	bool
	depends on HARDLOCKUP_DETECTOR
	depends on HAVE_HARDLOCKUP_DETECTOR_PERF && !HARDLOCKUP_DETECTOR_PREFER_BUDDY
	depends on !HAVE_HARDLOCKUP_DETECTOR_ARCH
	select HARDLOCKUP_DETECTOR_COUNTS_HRTIMER

config HARDLOCKUP_DETECTOR_BUDDY
	bool
	depends on HARDLOCKUP_DETECTOR
	depends on HAVE_HARDLOCKUP_DETECTOR_BUDDY
	depends on !HAVE_HARDLOCKUP_DETECTOR_PERF || HARDLOCKUP_DETECTOR_PREFER_BUDDY
	depends on !HAVE_HARDLOCKUP_DETECTOR_ARCH
	select HARDLOCKUP_DETECTOR_COUNTS_HRTIMER

config HARDLOCKUP_DETECTOR_ARCH
	bool
	depends on HARDLOCKUP_DETECTOR
	depends on HAVE_HARDLOCKUP_DETECTOR_ARCH
	help
	  The arch-specific implementation of the hardlockup detector will
	  be used.

#
# Both the "perf" and "buddy" hardlockup detectors count hrtimer
# interrupts. This config enables functions managing this common code.
#
config HARDLOCKUP_DETECTOR_COUNTS_HRTIMER
	bool
	select SOFTLOCKUP_DETECTOR

#
# Enables a timestamp based low pass filter to compensate for perf based
# hard lockup detection which runs too fast due to turbo modes.
#
config HARDLOCKUP_CHECK_TIMESTAMP
	bool

config BOOTPARAM_HARDLOCKUP_PANIC
	bool "Panic (Reboot) On Hard Lockups"
	depends on HARDLOCKUP_DETECTOR
	help
	  Say Y here to enable the kernel to panic on "hard lockups",
	  which are bugs that cause the kernel to loop in kernel
	  mode with interrupts disabled for more than 10 seconds (configurable
	  using the watchdog_thresh sysctl).

	  Say N if unsure.

config DETECT_HUNG_TASK
	bool "Detect Hung Tasks"
	depends on DEBUG_KERNEL
	default SOFTLOCKUP_DETECTOR
	help
	  Say Y here to enable the kernel to detect "hung tasks",
	  which are bugs that cause the task to be stuck in
	  uninterruptible "D" state indefinitely.

	  When a hung task is detected, the kernel will print the
	  current stack trace (which you should report), but the
	  task will stay in uninterruptible state. If lockdep is
	  enabled then all held locks will also be reported. This
	  feature has negligible overhead.

config DEFAULT_HUNG_TASK_TIMEOUT
	int "Default timeout for hung task detection (in seconds)"
	depends on DETECT_HUNG_TASK
	default 120
	help
	  This option controls the default timeout (in seconds) used
	  to determine when a task has become non-responsive and should
	  be considered hung.

	  It can be adjusted at runtime via the kernel.hung_task_timeout_secs
	  sysctl or by writing a value to
	  /proc/sys/kernel/hung_task_timeout_secs.

	  A timeout of 0 disables the check.  The default is two minutes.
	  Keeping the default should be fine in most cases.

config BOOTPARAM_HUNG_TASK_PANIC
	bool "Panic (Reboot) On Hung Tasks"
	depends on DETECT_HUNG_TASK
	help
	  Say Y here to enable the kernel to panic on "hung tasks",
	  which are bugs that cause the kernel to leave a task stuck
	  in uninterruptible "D" state.

	  The panic can be used in combination with panic_timeout,
	  to cause the system to reboot automatically after a
	  hung task has been detected. This feature is useful for
	  high-availability systems that have uptime guarantees and
	  where a hung tasks must be resolved ASAP.

	  Say N if unsure.

config DETECT_HUNG_TASK_BLOCKER
	bool "Dump Hung Tasks Blocker"
	depends on DETECT_HUNG_TASK
	depends on !PREEMPT_RT
	default y
	help
	  Say Y here to show the blocker task's stacktrace who acquires
	  the mutex lock which "hung tasks" are waiting.
	  This will add overhead a bit but shows suspicious tasks and
	  call trace if it comes from waiting a mutex.

config WQ_WATCHDOG
	bool "Detect Workqueue Stalls"
	depends on DEBUG_KERNEL
	help
	  Say Y here to enable stall detection on workqueues.  If a
	  worker pool doesn't make forward progress on a pending work
	  item for over a given amount of time, 30s by default, a
	  warning message is printed along with dump of workqueue
	  state.  This can be configured through kernel parameter
	  "workqueue.watchdog_thresh" and its sysfs counterpart.

config WQ_CPU_INTENSIVE_REPORT
	bool "Report per-cpu work items which hog CPU for too long"
	depends on DEBUG_KERNEL
	help
	  Say Y here to enable reporting of concurrency-managed per-cpu work
	  items that hog CPUs for longer than
	  workqueue.cpu_intensive_thresh_us. Workqueue automatically
	  detects and excludes them from concurrency management to prevent
	  them from stalling other per-cpu work items. Occassional
	  triggering may not necessarily indicate a problem. Repeated
	  triggering likely indicates that the work item should be switched
	  to use an unbound workqueue.

config TEST_LOCKUP
	tristate "Test module to generate lockups"
	depends on m
	help
	  This builds the "test_lockup" module that helps to make sure
	  that watchdogs and lockup detectors are working properly.

	  Depending on module parameters it could emulate soft or hard
	  lockup, "hung task", or locking arbitrary lock for a long time.
	  Also it could generate series of lockups with cooling-down periods.

	  If unsure, say N.

endmenu # "Debug lockups and hangs"

menu "Scheduler Debugging"

config SCHED_INFO
	bool
	default n

config SCHEDSTATS
	bool "Collect scheduler statistics"
	depends on PROC_FS
	select SCHED_INFO
	help
	  If you say Y here, additional code will be inserted into the
	  scheduler and related routines to collect statistics about
	  scheduler behavior and provide them in /proc/schedstat.  These
	  stats may be useful for both tuning and debugging the scheduler
	  If you aren't debugging the scheduler or trying to tune a specific
	  application, you can say N to avoid the very slight overhead
	  this adds.

endmenu

config DEBUG_PREEMPT
	bool "Debug preemptible kernel"
	depends on DEBUG_KERNEL && PREEMPTION && TRACE_IRQFLAGS_SUPPORT
	help
	  If you say Y here then the kernel will use a debug variant of the
	  commonly used smp_processor_id() function and will print warnings
	  if kernel code uses it in a preemption-unsafe way. Also, the kernel
	  will detect preemption count underflows.

	  This option has potential to introduce high runtime overhead,
	  depending on workload as it triggers debugging routines for each
	  this_cpu operation. It should only be used for debugging purposes.

menu "Lock Debugging (spinlocks, mutexes, etc...)"

config LOCK_DEBUGGING_SUPPORT
	bool
	depends on TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT
	default y

config PROVE_LOCKING
	bool "Lock debugging: prove locking correctness"
	depends on DEBUG_KERNEL && LOCK_DEBUGGING_SUPPORT
	select LOCKDEP
	select DEBUG_SPINLOCK
	select DEBUG_MUTEXES if !PREEMPT_RT
	select DEBUG_RT_MUTEXES if RT_MUTEXES
	select DEBUG_RWSEMS if !PREEMPT_RT
	select DEBUG_WW_MUTEX_SLOWPATH
	select DEBUG_LOCK_ALLOC
	select PREEMPT_COUNT if !ARCH_NO_PREEMPT
	select TRACE_IRQFLAGS
	default n
	help
	 This feature enables the kernel to prove that all locking
	 that occurs in the kernel runtime is mathematically
	 correct: that under no circumstance could an arbitrary (and
	 not yet triggered) combination of observed locking
	 sequences (on an arbitrary number of CPUs, running an
	 arbitrary number of tasks and interrupt contexts) cause a
	 deadlock.

	 In short, this feature enables the kernel to report locking
	 related deadlocks before they actually occur.

	 The proof does not depend on how hard and complex a
	 deadlock scenario would be to trigger: how many
	 participant CPUs, tasks and irq-contexts would be needed
	 for it to trigger. The proof also does not depend on
	 timing: if a race and a resulting deadlock is possible
	 theoretically (no matter how unlikely the race scenario
	 is), it will be proven so and will immediately be
	 reported by the kernel (once the event is observed that
	 makes the deadlock theoretically possible).

	 If a deadlock is impossible (i.e. the locking rules, as
	 observed by the kernel, are mathematically correct), the
	 kernel reports nothing.

	 NOTE: this feature can also be enabled for rwlocks, mutexes
	 and rwsems - in which case all dependencies between these
	 different locking variants are observed and mapped too, and
	 the proof of observed correctness is also maintained for an
	 arbitrary combination of these separate locking variants.

	 For more details, see Documentation/locking/lockdep-design.rst.

config PROVE_RAW_LOCK_NESTING
	bool "Enable raw_spinlock - spinlock nesting checks" if !ARCH_SUPPORTS_RT
	depends on PROVE_LOCKING
	default y if ARCH_SUPPORTS_RT
	help
	 Enable the raw_spinlock vs. spinlock nesting checks which ensure
	 that the lock nesting rules for PREEMPT_RT enabled kernels are
	 not violated.

config LOCK_STAT
	bool "Lock usage statistics"
	depends on DEBUG_KERNEL && LOCK_DEBUGGING_SUPPORT
	select LOCKDEP
	select DEBUG_SPINLOCK
	select DEBUG_MUTEXES if !PREEMPT_RT
	select DEBUG_RT_MUTEXES if RT_MUTEXES
	select DEBUG_LOCK_ALLOC
	default n
	help
	 This feature enables tracking lock contention points

	 For more details, see Documentation/locking/lockstat.rst

	 This also enables lock events required by "perf lock",
	 subcommand of perf.
	 If you want to use "perf lock", you also need to turn on
	 CONFIG_EVENT_TRACING.

	 CONFIG_LOCK_STAT defines "contended" and "acquired" lock events.
	 (CONFIG_LOCKDEP defines "acquire" and "release" events.)

config DEBUG_RT_MUTEXES
	bool "RT Mutex debugging, deadlock detection"
	depends on DEBUG_KERNEL && RT_MUTEXES
	help
	 This allows rt mutex semantics violations and rt mutex related
	 deadlocks (lockups) to be detected and reported automatically.

config DEBUG_SPINLOCK
	bool "Spinlock and rw-lock debugging: basic checks"
	depends on DEBUG_KERNEL
	select UNINLINE_SPIN_UNLOCK
	help
	  Say Y here and build SMP to catch missing spinlock initialization
	  and certain other kinds of spinlock errors commonly made.  This is
	  best used in conjunction with the NMI watchdog so that spinlock
	  deadlocks are also debuggable.

config DEBUG_MUTEXES
	bool "Mutex debugging: basic checks"
	depends on DEBUG_KERNEL && !PREEMPT_RT
	help
	 This feature allows mutex semantics violations to be detected and
	 reported.

config DEBUG_WW_MUTEX_SLOWPATH
	bool "Wait/wound mutex debugging: Slowpath testing"
	depends on DEBUG_KERNEL && LOCK_DEBUGGING_SUPPORT
	select DEBUG_LOCK_ALLOC
	select DEBUG_SPINLOCK
	select DEBUG_MUTEXES if !PREEMPT_RT
	select DEBUG_RT_MUTEXES if PREEMPT_RT
	help
	 This feature enables slowpath testing for w/w mutex users by
	 injecting additional -EDEADLK wound/backoff cases. Together with
	 the full mutex checks enabled with (CONFIG_PROVE_LOCKING) this
	 will test all possible w/w mutex interface abuse with the
	 exception of simply not acquiring all the required locks.
	 Note that this feature can introduce significant overhead, so
	 it really should not be enabled in a production or distro kernel,
	 even a debug kernel.  If you are a driver writer, enable it.  If
	 you are a distro, do not.

config DEBUG_RWSEMS
	bool "RW Semaphore debugging: basic checks"
	depends on DEBUG_KERNEL && !PREEMPT_RT
	help
	  This debugging feature allows mismatched rw semaphore locks
	  and unlocks to be detected and reported.

config DEBUG_LOCK_ALLOC
	bool "Lock debugging: detect incorrect freeing of live locks"
	depends on DEBUG_KERNEL && LOCK_DEBUGGING_SUPPORT
	select DEBUG_SPINLOCK
	select DEBUG_MUTEXES if !PREEMPT_RT
	select DEBUG_RT_MUTEXES if RT_MUTEXES
	select LOCKDEP
	help
	 This feature will check whether any held lock (spinlock, rwlock,
	 mutex or rwsem) is incorrectly freed by the kernel, via any of the
	 memory-freeing routines (kfree(), kmem_cache_free(), free_pages(),
	 vfree(), etc.), whether a live lock is incorrectly reinitialized via
	 spin_lock_init()/mutex_init()/etc., or whether there is any lock
	 held during task exit.

config LOCKDEP
	bool
	depends on DEBUG_KERNEL && LOCK_DEBUGGING_SUPPORT
	select STACKTRACE
	select KALLSYMS
	select KALLSYMS_ALL

config LOCKDEP_SMALL
	bool

config LOCKDEP_BITS
	int "Size for MAX_LOCKDEP_ENTRIES (as Nth power of 2)"
	depends on LOCKDEP && !LOCKDEP_SMALL
	range 10 24
	default 15
	help
	  Try increasing this value if you hit "BUG: MAX_LOCKDEP_ENTRIES too low!" message.

config LOCKDEP_CHAINS_BITS
	int "Size for MAX_LOCKDEP_CHAINS (as Nth power of 2)"
	depends on LOCKDEP && !LOCKDEP_SMALL
	range 10 21
	default 16
	help
	  Try increasing this value if you hit "BUG: MAX_LOCKDEP_CHAINS too low!" message.

config LOCKDEP_STACK_TRACE_BITS
	int "Size for MAX_STACK_TRACE_ENTRIES (as Nth power of 2)"
	depends on LOCKDEP && !LOCKDEP_SMALL
	range 10 26
	default 19
	help
	  Try increasing this value if you hit "BUG: MAX_STACK_TRACE_ENTRIES too low!" message.

config LOCKDEP_STACK_TRACE_HASH_BITS
	int "Size for STACK_TRACE_HASH_SIZE (as Nth power of 2)"
	depends on LOCKDEP && !LOCKDEP_SMALL
	range 10 26
	default 14
	help
	  Try increasing this value if you need large STACK_TRACE_HASH_SIZE.

config LOCKDEP_CIRCULAR_QUEUE_BITS
	int "Size for elements in circular_queue struct (as Nth power of 2)"
	depends on LOCKDEP
	range 10 26
	default 12
	help
	  Try increasing this value if you hit "lockdep bfs error:-1" warning due to __cq_enqueue() failure.

config DEBUG_LOCKDEP
	bool "Lock dependency engine debugging"
	depends on DEBUG_KERNEL && LOCKDEP
	select DEBUG_IRQFLAGS
	help
	  If you say Y here, the lock dependency engine will do
	  additional runtime checks to debug itself, at the price
	  of more runtime overhead.

config DEBUG_ATOMIC_SLEEP
	bool "Sleep inside atomic section checking"
	select PREEMPT_COUNT
	depends on DEBUG_KERNEL
	depends on !ARCH_NO_PREEMPT
	help
	  If you say Y here, various routines which may sleep will become very
	  noisy if they are called inside atomic sections: when a spinlock is
	  held, inside an rcu read side critical section, inside preempt disabled
	  sections, inside an interrupt, etc...

config DEBUG_LOCKING_API_SELFTESTS
	bool "Locking API boot-time self-tests"
	depends on DEBUG_KERNEL
	help
	  Say Y here if you want the kernel to run a short self-test during
	  bootup. The self-test checks whether common types of locking bugs
	  are detected by debugging mechanisms or not. (if you disable
	  lock debugging then those bugs won't be detected of course.)
	  The following locking APIs are covered: spinlocks, rwlocks,
	  mutexes and rwsems.

config LOCK_TORTURE_TEST
	tristate "torture tests for locking"
	depends on DEBUG_KERNEL
	select TORTURE_TEST
	help
	  This option provides a kernel module that runs torture tests
	  on kernel locking primitives.  The kernel module may be built
	  after the fact on the running kernel to be tested, if desired.

	  Say Y here if you want kernel locking-primitive torture tests
	  to be built into the kernel.
	  Say M if you want these torture tests to build as a module.
	  Say N if you are unsure.

config WW_MUTEX_SELFTEST
	tristate "Wait/wound mutex selftests"
	help
	  This option provides a kernel module that runs tests on the
	  on the struct ww_mutex locking API.

	  It is recommended to enable DEBUG_WW_MUTEX_SLOWPATH in conjunction
	  with this test harness.

	  Say M if you want these self tests to build as a module.
	  Say N if you are unsure.

config SCF_TORTURE_TEST
	tristate "torture tests for smp_call_function*()"
	depends on DEBUG_KERNEL
	select TORTURE_TEST
	help
	  This option provides a kernel module that runs torture tests
	  on the smp_call_function() family of primitives.  The kernel
	  module may be built after the fact on the running kernel to
	  be tested, if desired.

config CSD_LOCK_WAIT_DEBUG
	bool "Debugging for csd_lock_wait(), called from smp_call_function*()"
	depends on DEBUG_KERNEL
	depends on SMP
	depends on 64BIT
	default n
	help
	  This option enables debug prints when CPUs are slow to respond
	  to the smp_call_function*() IPI wrappers.  These debug prints
	  include the IPI handler function currently executing (if any)
	  and relevant stack traces.

config CSD_LOCK_WAIT_DEBUG_DEFAULT
	bool "Default csd_lock_wait() debugging on at boot time"
	depends on CSD_LOCK_WAIT_DEBUG
	depends on 64BIT
	default n
	help
	  This option causes the csdlock_debug= kernel boot parameter to
	  default to 1 (basic debugging) instead of 0 (no debugging).

endmenu # lock debugging

config TRACE_IRQFLAGS
	depends on TRACE_IRQFLAGS_SUPPORT
	bool
	help
	  Enables hooks to interrupt enabling and disabling for
	  either tracing or lock debugging.

config TRACE_IRQFLAGS_NMI
	def_bool y
	depends on TRACE_IRQFLAGS
	depends on TRACE_IRQFLAGS_NMI_SUPPORT

config NMI_CHECK_CPU
	bool "Debugging for CPUs failing to respond to backtrace requests"
	depends on DEBUG_KERNEL
	depends on X86
	default n
	help
	  Enables debug prints when a CPU fails to respond to a given
	  backtrace NMI.  These prints provide some reasons why a CPU
	  might legitimately be failing to respond, for example, if it
	  is offline of if ignore_nmis is set.

config DEBUG_IRQFLAGS
	bool "Debug IRQ flag manipulation"
	help
	  Enables checks for potentially unsafe enabling or disabling of
	  interrupts, such as calling raw_local_irq_restore() when interrupts
	  are enabled.

config STACKTRACE
	bool "Stack backtrace support"
	depends on STACKTRACE_SUPPORT
	help
	  This option causes the kernel to create a /proc/pid/stack for
	  every process, showing its current stack trace.
	  It is also used by various kernel debugging features that require
	  stack trace generation.

config WARN_ALL_UNSEEDED_RANDOM
	bool "Warn for all uses of unseeded randomness"
	default n
	help
	  Some parts of the kernel contain bugs relating to their use of
	  cryptographically secure random numbers before it's actually possible
	  to generate those numbers securely. This setting ensures that these
	  flaws don't go unnoticed, by enabling a message, should this ever
	  occur. This will allow people with obscure setups to know when things
	  are going wrong, so that they might contact developers about fixing
	  it.

	  Unfortunately, on some models of some architectures getting
	  a fully seeded CRNG is extremely difficult, and so this can
	  result in dmesg getting spammed for a surprisingly long
	  time.  This is really bad from a security perspective, and
	  so architecture maintainers really need to do what they can
	  to get the CRNG seeded sooner after the system is booted.
	  However, since users cannot do anything actionable to
	  address this, by default this option is disabled.

	  Say Y here if you want to receive warnings for all uses of
	  unseeded randomness.  This will be of use primarily for
	  those developers interested in improving the security of
	  Linux kernels running on their architecture (or
	  subarchitecture).

config DEBUG_KOBJECT
	bool "kobject debugging"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, some extra kobject debugging messages will be sent
	  to the syslog.

config DEBUG_KOBJECT_RELEASE
	bool "kobject release debugging"
	depends on DEBUG_OBJECTS_TIMERS
	help
	  kobjects are reference counted objects.  This means that their
	  last reference count put is not predictable, and the kobject can
	  live on past the point at which a driver decides to drop its
	  initial reference to the kobject gained on allocation.  An
	  example of this would be a struct device which has just been
	  unregistered.

	  However, some buggy drivers assume that after such an operation,
	  the memory backing the kobject can be immediately freed.  This
	  goes completely against the principles of a refcounted object.

	  If you say Y here, the kernel will delay the release of kobjects
	  on the last reference count to improve the visibility of this
	  kind of kobject release bug.

config HAVE_DEBUG_BUGVERBOSE
	bool

menu "Debug kernel data structures"

config DEBUG_LIST
	bool "Debug linked list manipulation"
	depends on DEBUG_KERNEL
	select LIST_HARDENED
	help
	  Enable this to turn on extended checks in the linked-list walking
	  routines.

	  This option trades better quality error reports for performance, and
	  is more suitable for kernel debugging. If you care about performance,
	  you should only enable CONFIG_LIST_HARDENED instead.

	  If unsure, say N.

config DEBUG_PLIST
	bool "Debug priority linked list manipulation"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on extended checks in the priority-ordered
	  linked-list (plist) walking routines.  This checks the entire
	  list multiple times during each manipulation.

	  If unsure, say N.

config DEBUG_SG
	bool "Debug SG table operations"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on checks on scatter-gather tables. This can
	  help find problems with drivers that do not properly initialize
	  their sg tables.

	  If unsure, say N.

config DEBUG_NOTIFIERS
	bool "Debug notifier call chains"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on sanity checking for notifier call chains.
	  This is most useful for kernel developers to make sure that
	  modules properly unregister themselves from notifier chains.
	  This is a relatively cheap check but if you care about maximum
	  performance, say N.

config DEBUG_CLOSURES
	bool "Debug closures (bcache async widgits)"
	depends on CLOSURES
	select DEBUG_FS
	help
	  Keeps all active closures in a linked list and provides a debugfs
	  interface to list them, which makes it possible to see asynchronous
	  operations that get stuck.

config DEBUG_MAPLE_TREE
	bool "Debug maple trees"
	depends on DEBUG_KERNEL
	help
	  Enable maple tree debugging information and extra validations.

	  If unsure, say N.

endmenu

source "kernel/rcu/Kconfig.debug"

config DEBUG_WQ_FORCE_RR_CPU
	bool "Force round-robin CPU selection for unbound work items"
	depends on DEBUG_KERNEL
	default n
	help
	  Workqueue used to implicitly guarantee that work items queued
	  without explicit CPU specified are put on the local CPU.  This
	  guarantee is no longer true and while local CPU is still
	  preferred work items may be put on foreign CPUs.  Kernel
	  parameter "workqueue.debug_force_rr_cpu" is added to force
	  round-robin CPU selection to flush out usages which depend on the
	  now broken guarantee.  This config option enables the debug
	  feature by default.  When enabled, memory and cache locality will
	  be impacted.

config CPU_HOTPLUG_STATE_CONTROL
	bool "Enable CPU hotplug state control"
	depends on DEBUG_KERNEL
	depends on HOTPLUG_CPU
	default n
	help
	  Allows to write steps between "offline" and "online" to the CPUs
	  sysfs target file so states can be stepped granular. This is a debug
	  option for now as the hotplug machinery cannot be stopped and
	  restarted at arbitrary points yet.

	  Say N if your are unsure.

config LATENCYTOP
	bool "Latency measuring infrastructure"
	depends on DEBUG_KERNEL
	depends on STACKTRACE_SUPPORT
	depends on PROC_FS
	depends on FRAME_POINTER || MIPS || PPC || S390 || MICROBLAZE || ARM || ARC || X86
	select KALLSYMS
	select KALLSYMS_ALL
	select STACKTRACE
	select SCHEDSTATS
	help
	  Enable this option if you want to use the LatencyTOP tool
	  to find out which userspace is blocking on what kernel operations.

config DEBUG_CGROUP_REF
	bool "Disable inlining of cgroup css reference count functions"
	depends on DEBUG_KERNEL
	depends on CGROUPS
	depends on KPROBES
	default n
	help
	  Force cgroup css reference count functions to not be inlined so
	  that they can be kprobed for debugging.

source "kernel/trace/Kconfig"

config PROVIDE_OHCI1394_DMA_INIT
	bool "Remote debugging over FireWire early on boot"
	depends on PCI && X86
	help
	  If you want to debug problems which hang or crash the kernel early
	  on boot and the crashing machine has a FireWire port, you can use
	  this feature to remotely access the memory of the crashed machine
	  over FireWire. This employs remote DMA as part of the OHCI1394
	  specification which is now the standard for FireWire controllers.

	  With remote DMA, you can monitor the printk buffer remotely using
	  firescope and access all memory below 4GB using fireproxy from gdb.
	  Even controlling a kernel debugger is possible using remote DMA.

	  Usage:

	  If ohci1394_dma=early is used as boot parameter, it will initialize
	  all OHCI1394 controllers which are found in the PCI config space.

	  As all changes to the FireWire bus such as enabling and disabling
	  devices cause a bus reset and thereby disable remote DMA for all
	  devices, be sure to have the cable plugged and FireWire enabled on
	  the debugging host before booting the debug target for debugging.

	  This code (~1k) is freed after boot. By then, the firewire stack
	  in charge of the OHCI-1394 controllers should be used instead.

	  See Documentation/core-api/debugging-via-ohci1394.rst for more information.

source "samples/Kconfig"

config ARCH_HAS_DEVMEM_IS_ALLOWED
	bool

config STRICT_DEVMEM
	bool "Filter access to /dev/mem"
	depends on MMU && DEVMEM
	depends on ARCH_HAS_DEVMEM_IS_ALLOWED || GENERIC_LIB_DEVMEM_IS_ALLOWED
	default y if PPC || X86 || ARM64 || S390
	help
	  If this option is disabled, you allow userspace (root) access to all
	  of memory, including kernel and userspace memory. Accidental
	  access to this is obviously disastrous, but specific access can
	  be used by people debugging the kernel. Note that with PAT support
	  enabled, even in this case there are restrictions on /dev/mem
	  use due to the cache aliasing requirements.

	  If this option is switched on, and IO_STRICT_DEVMEM=n, the /dev/mem
	  file only allows userspace access to PCI space and the BIOS code and
	  data regions.  This is sufficient for dosemu and X and all common
	  users of /dev/mem.

	  If in doubt, say Y.

config IO_STRICT_DEVMEM
	bool "Filter I/O access to /dev/mem"
	depends on STRICT_DEVMEM
	help
	  If this option is disabled, you allow userspace (root) access to all
	  io-memory regardless of whether a driver is actively using that
	  range.  Accidental access to this is obviously disastrous, but
	  specific access can be used by people debugging kernel drivers.

	  If this option is switched on, the /dev/mem file only allows
	  userspace access to *idle* io-memory ranges (see /proc/iomem) This
	  may break traditional users of /dev/mem (dosemu, legacy X, etc...)
	  if the driver using a given range cannot be disabled.

	  If in doubt, say Y.

menu "$(SRCARCH) Debugging"

source "arch/$(SRCARCH)/Kconfig.debug"

endmenu

menu "Kernel Testing and Coverage"

source "lib/kunit/Kconfig"

config NOTIFIER_ERROR_INJECTION
	tristate "Notifier error injection"
	depends on DEBUG_KERNEL
	select DEBUG_FS
	help
	  This option provides the ability to inject artificial errors to
	  specified notifier chain callbacks. It is useful to test the error
	  handling of notifier call chain failures.

	  Say N if unsure.

config PM_NOTIFIER_ERROR_INJECT
	tristate "PM notifier error injection module"
	depends on PM && NOTIFIER_ERROR_INJECTION
	default m if PM_DEBUG
	help
	  This option provides the ability to inject artificial errors to
	  PM notifier chain callbacks.  It is controlled through debugfs
	  interface /sys/kernel/debug/notifier-error-inject/pm

	  If the notifier call chain should be failed with some events
	  notified, write the error code to "actions/<notifier event>/error".

	  Example: Inject PM suspend error (-12 = -ENOMEM)

	  # cd /sys/kernel/debug/notifier-error-inject/pm/
	  # echo -12 > actions/PM_SUSPEND_PREPARE/error
	  # echo mem > /sys/power/state
	  bash: echo: write error: Cannot allocate memory

	  To compile this code as a module, choose M here: the module will
	  be called pm-notifier-error-inject.

	  If unsure, say N.

config OF_RECONFIG_NOTIFIER_ERROR_INJECT
	tristate "OF reconfig notifier error injection module"
	depends on OF_DYNAMIC && NOTIFIER_ERROR_INJECTION
	help
	  This option provides the ability to inject artificial errors to
	  OF reconfig notifier chain callbacks.  It is controlled
	  through debugfs interface under
	  /sys/kernel/debug/notifier-error-inject/OF-reconfig/

	  If the notifier call chain should be failed with some events
	  notified, write the error code to "actions/<notifier event>/error".

	  To compile this code as a module, choose M here: the module will
	  be called of-reconfig-notifier-error-inject.

	  If unsure, say N.

config NETDEV_NOTIFIER_ERROR_INJECT
	tristate "Netdev notifier error injection module"
	depends on NET && NOTIFIER_ERROR_INJECTION
	help
	  This option provides the ability to inject artificial errors to
	  netdevice notifier chain callbacks.  It is controlled through debugfs
	  interface /sys/kernel/debug/notifier-error-inject/netdev

	  If the notifier call chain should be failed with some events
	  notified, write the error code to "actions/<notifier event>/error".

	  Example: Inject netdevice mtu change error (-22 = -EINVAL)

	  # cd /sys/kernel/debug/notifier-error-inject/netdev
	  # echo -22 > actions/NETDEV_CHANGEMTU/error
	  # ip link set eth0 mtu 1024
	  RTNETLINK answers: Invalid argument

	  To compile this code as a module, choose M here: the module will
	  be called netdev-notifier-error-inject.

	  If unsure, say N.

config FUNCTION_ERROR_INJECTION
	bool "Fault-injections of functions"
	depends on HAVE_FUNCTION_ERROR_INJECTION && KPROBES
	help
	  Add fault injections into various functions that are annotated with
	  ALLOW_ERROR_INJECTION() in the kernel. BPF may also modify the return
	  value of these functions. This is useful to test error paths of code.

	  If unsure, say N

config FAULT_INJECTION
	bool "Fault-injection framework"
	depends on DEBUG_KERNEL
	help
	  Provide fault-injection framework.
	  For more details, see Documentation/fault-injection/.

config FAILSLAB
	bool "Fault-injection capability for kmalloc"
	depends on FAULT_INJECTION
	help
	  Provide fault-injection capability for kmalloc.

config FAIL_PAGE_ALLOC
	bool "Fault-injection capability for alloc_pages()"
	depends on FAULT_INJECTION
	help
	  Provide fault-injection capability for alloc_pages().

config FAULT_INJECTION_USERCOPY
	bool "Fault injection capability for usercopy functions"
	depends on FAULT_INJECTION
	help
	  Provides fault-injection capability to inject failures
	  in usercopy functions (copy_from_user(), get_user(), ...).

config FAIL_MAKE_REQUEST
	bool "Fault-injection capability for disk IO"
	depends on FAULT_INJECTION && BLOCK
	help
	  Provide fault-injection capability for disk IO.

config FAIL_IO_TIMEOUT
	bool "Fault-injection capability for faking disk interrupts"
	depends on FAULT_INJECTION && BLOCK
	help
	  Provide fault-injection capability on end IO handling. This
	  will make the block layer "forget" an interrupt as configured,
	  thus exercising the error handling.

	  Only works with drivers that use the generic timeout handling,
	  for others it won't do anything.

config FAIL_FUTEX
	bool "Fault-injection capability for futexes"
	select DEBUG_FS
	depends on FAULT_INJECTION && FUTEX
	help
	  Provide fault-injection capability for futexes.

config FAULT_INJECTION_DEBUG_FS
	bool "Debugfs entries for fault-injection capabilities"
	depends on FAULT_INJECTION && SYSFS && DEBUG_FS
	help
	  Enable configuration of fault-injection capabilities via debugfs.

config FAIL_FUNCTION
	bool "Fault-injection capability for functions"
	depends on FAULT_INJECTION_DEBUG_FS && FUNCTION_ERROR_INJECTION
	help
	  Provide function-based fault-injection capability.
	  This will allow you to override a specific function with a return
	  with given return value. As a result, function caller will see
	  an error value and have to handle it. This is useful to test the
	  error handling in various subsystems.

config FAIL_MMC_REQUEST
	bool "Fault-injection capability for MMC IO"
	depends on FAULT_INJECTION_DEBUG_FS && MMC
	help
	  Provide fault-injection capability for MMC IO.
	  This will make the mmc core return data errors. This is
	  useful to test the error handling in the mmc block device
	  and to test how the mmc host driver handles retries from
	  the block device.

config FAIL_SUNRPC
	bool "Fault-injection capability for SunRPC"
	depends on FAULT_INJECTION_DEBUG_FS && SUNRPC_DEBUG
	help
	  Provide fault-injection capability for SunRPC and
	  its consumers.

config FAIL_SKB_REALLOC
	bool "Fault-injection capability forcing skb to reallocate"
	depends on FAULT_INJECTION_DEBUG_FS
	help
	  Provide fault-injection capability that forces the skb to be
	  reallocated, catching possible invalid pointers to the skb.

	  For more information, check
	  Documentation/fault-injection/fault-injection.rst

config FAULT_INJECTION_CONFIGFS
	bool "Configfs interface for fault-injection capabilities"
	depends on FAULT_INJECTION
	select CONFIGFS_FS
	help
	  This option allows configfs-based drivers to dynamically configure
	  fault-injection via configfs.  Each parameter for driver-specific
	  fault-injection can be made visible as a configfs attribute in a
	  configfs group.


config FAULT_INJECTION_STACKTRACE_FILTER
	bool "stacktrace filter for fault-injection capabilities"
	depends on FAULT_INJECTION
	depends on (FAULT_INJECTION_DEBUG_FS || FAULT_INJECTION_CONFIGFS) && STACKTRACE_SUPPORT
	select STACKTRACE
	depends on FRAME_POINTER || MIPS || PPC || S390 || MICROBLAZE || ARM || ARC || X86
	help
	  Provide stacktrace filter for fault-injection capabilities

config ARCH_HAS_KCOV
	bool
	help
	  An architecture should select this when it can successfully
	  build and run with CONFIG_KCOV. This typically requires
	  disabling instrumentation for some early boot code.

config KCOV
	bool "Code coverage for fuzzing"
	depends on ARCH_HAS_KCOV
	depends on !ARCH_WANTS_NO_INSTR || HAVE_NOINSTR_HACK || \
		   GCC_VERSION >= 120000 || CC_IS_CLANG
	select DEBUG_FS
	select OBJTOOL if HAVE_NOINSTR_HACK
	help
	  KCOV exposes kernel code coverage information in a form suitable
	  for coverage-guided fuzzing (randomized testing).

	  For more details, see Documentation/dev-tools/kcov.rst.

config KCOV_ENABLE_COMPARISONS
	bool "Enable comparison operands collection by KCOV"
	depends on KCOV
	depends on $(cc-option,-fsanitize-coverage=trace-cmp)
	help
	  KCOV also exposes operands of every comparison in the instrumented
	  code along with operand sizes and PCs of the comparison instructions.
	  These operands can be used by fuzzing engines to improve the quality
	  of fuzzing coverage.

config KCOV_INSTRUMENT_ALL
	bool "Instrument all code by default"
	depends on KCOV
	default y
	help
	  If you are doing generic system call fuzzing (like e.g. syzkaller),
	  then you will want to instrument the whole kernel and you should
	  say y here. If you are doing more targeted fuzzing (like e.g.
	  filesystem fuzzing with AFL) then you will want to enable coverage
	  for more specific subsets of files, and should say n here.

config KCOV_IRQ_AREA_SIZE
	hex "Size of interrupt coverage collection area in words"
	depends on KCOV
	default 0x40000
	help
	  KCOV uses preallocated per-cpu areas to collect coverage from
	  soft interrupts. This specifies the size of those areas in the
	  number of unsigned long words.

config KCOV_SELFTEST
	bool "Perform short selftests on boot"
	depends on KCOV
	help
	  Run short KCOV coverage collection selftests on boot.
	  On test failure, causes the kernel to panic. Recommended to be
	  enabled, ensuring critical functionality works as intended.

menuconfig RUNTIME_TESTING_MENU
	bool "Runtime Testing"
	default y

if RUNTIME_TESTING_MENU

config TEST_DHRY
	tristate "Dhrystone benchmark test"
	help
	  Enable this to include the Dhrystone 2.1 benchmark.  This test
	  calculates the number of Dhrystones per second, and the number of
	  DMIPS (Dhrystone MIPS) obtained when the Dhrystone score is divided
	  by 1757 (the number of Dhrystones per second obtained on the VAX
	  11/780, nominally a 1 MIPS machine).

	  To run the benchmark, it needs to be enabled explicitly, either from
	  the kernel command line (when built-in), or from userspace (when
	  built-in or modular).

	  Run once during kernel boot:

	      test_dhry.run

	  Set number of iterations from kernel command line:

	      test_dhry.iterations=<n>

	  Set number of iterations from userspace:

	      echo <n> > /sys/module/test_dhry/parameters/iterations

	  Trigger manual run from userspace:

	      echo y > /sys/module/test_dhry/parameters/run

	  If the number of iterations is <= 0, the test will devise a suitable
	  number of iterations (test runs for at least 2s) automatically.
	  This process takes ca. 4s.

	  If unsure, say N.

config LKDTM
	tristate "Linux Kernel Dump Test Tool Module"
	depends on DEBUG_FS
	help
	This module enables testing of the different dumping mechanisms by
	inducing system failures at predefined crash points.
	If you don't need it: say N
	Choose M here to compile this code as a module. The module will be
	called lkdtm.

	Documentation on how to use the module can be found in
	Documentation/fault-injection/provoke-crashes.rst

config CPUMASK_KUNIT_TEST
	tristate "KUnit test for cpumask" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable to turn on cpumask tests, running at boot or module load time.

	  For more information on KUnit and unit tests in general, please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config MEAN_AND_VARIANCE_UNIT_TEST
	tristate "mean_and_variance unit tests" if !KUNIT_ALL_TESTS
	depends on KUNIT
	select MEAN_AND_VARIANCE
	default KUNIT_ALL_TESTS
	help
	  This option enables the kunit tests for mean_and_variance module.
	  If unsure, say N.

config TEST_LIST_SORT
	tristate "Linked list sorting test" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this to turn on 'list_sort()' function test. This test is
	  executed only once during system boot (so affects only boot time),
	  or at module load time.

	  If unsure, say N.

config TEST_MIN_HEAP
	tristate "Min heap test"
	depends on DEBUG_KERNEL || m
	help
	  Enable this to turn on min heap function tests. This test is
	  executed only once during system boot (so affects only boot time),
	  or at module load time.

	  If unsure, say N.

config TEST_SORT
	tristate "Array-based sort test" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This option enables the self-test function of 'sort()' at boot,
	  or at module load time.

	  If unsure, say N.

config TEST_DIV64
	tristate "64bit/32bit division and modulo test"
	depends on DEBUG_KERNEL || m
	help
	  Enable this to turn on 'do_div()' function test. This test is
	  executed only once during system boot (so affects only boot time),
	  or at module load time.

	  If unsure, say N.

config TEST_MULDIV64
	tristate "mul_u64_u64_div_u64() test"
	depends on DEBUG_KERNEL || m
	help
	  Enable this to turn on 'mul_u64_u64_div_u64()' function test.
	  This test is executed only once during system boot (so affects
	  only boot time), or at module load time.

	  If unsure, say N.

config TEST_IOV_ITER
	tristate "Test iov_iter operation" if !KUNIT_ALL_TESTS
	depends on KUNIT
	depends on MMU
	default KUNIT_ALL_TESTS
	help
	  Enable this to turn on testing of the operation of the I/O iterator
	  (iov_iter). This test is executed only once during system boot (so
	  affects only boot time), or at module load time.

	  If unsure, say N.

config KPROBES_SANITY_TEST
	tristate "Kprobes sanity tests" if !KUNIT_ALL_TESTS
	depends on DEBUG_KERNEL
	depends on KPROBES
	depends on KUNIT
	select STACKTRACE if ARCH_CORRECT_STACKTRACE_ON_KRETPROBE
	default KUNIT_ALL_TESTS
	help
	  This option provides for testing basic kprobes functionality on
	  boot. Samples of kprobe and kretprobe are inserted and
	  verified for functionality.

	  Say N if you are unsure.

config FPROBE_SANITY_TEST
	bool "Self test for fprobe"
	depends on DEBUG_KERNEL
	depends on FPROBE
	depends on KUNIT=y
	help
	  This option will enable testing the fprobe when the system boot.
	  A series of tests are made to verify that the fprobe is functioning
	  properly.

	  Say N if you are unsure.

config BACKTRACE_SELF_TEST
	tristate "Self test for the backtrace code"
	depends on DEBUG_KERNEL
	help
	  This option provides a kernel module that can be used to test
	  the kernel stack backtrace code. This option is not useful
	  for distributions or general kernels, but only for kernel
	  developers working on architecture code.

	  Note that if you want to also test saved backtraces, you will
	  have to enable STACKTRACE as well.

	  Say N if you are unsure.

config TEST_REF_TRACKER
	tristate "Self test for reference tracker"
	depends on DEBUG_KERNEL && STACKTRACE_SUPPORT
	select REF_TRACKER
	help
	  This option provides a kernel module performing tests
	  using reference tracker infrastructure.

	  Say N if you are unsure.

config RBTREE_TEST
	tristate "Red-Black tree test"
	depends on DEBUG_KERNEL
	help
	  A benchmark measuring the performance of the rbtree library.
	  Also includes rbtree invariant checks.

config REED_SOLOMON_TEST
	tristate "Reed-Solomon library test"
	depends on DEBUG_KERNEL || m
	select REED_SOLOMON
	select REED_SOLOMON_ENC16
	select REED_SOLOMON_DEC16
	help
	  This option enables the self-test function of rslib at boot,
	  or at module load time.

	  If unsure, say N.

config INTERVAL_TREE_TEST
	tristate "Interval tree test"
	depends on DEBUG_KERNEL
	select INTERVAL_TREE
	help
	  A benchmark measuring the performance of the interval tree library

config PERCPU_TEST
	tristate "Per cpu operations test"
	depends on m && DEBUG_KERNEL
	help
	  Enable this option to build test module which validates per-cpu
	  operations.

	  If unsure, say N.

config ATOMIC64_SELFTEST
	tristate "Perform an atomic64_t self-test"
	help
	  Enable this option to test the atomic64_t functions at boot or
	  at module load time.

	  If unsure, say N.

config ASYNC_RAID6_TEST
	tristate "Self test for hardware accelerated raid6 recovery"
	depends on ASYNC_RAID6_RECOV
	select ASYNC_MEMCPY
	help
	  This is a one-shot self test that permutes through the
	  recovery of all the possible two disk failure scenarios for a
	  N-disk array.  Recovery is performed with the asynchronous
	  raid6 recovery routines, and will optionally use an offload
	  engine if one is available.

	  If unsure, say N.

config TEST_HEXDUMP
	tristate "Test functions located in the hexdump module at runtime"

config PRINTF_KUNIT_TEST
	tristate "KUnit test printf() family of functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this option to test the printf functions at runtime.

	  If unsure, say N.

config SCANF_KUNIT_TEST
	tristate "KUnit test scanf() family of functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this option to test the scanf functions at runtime.

	  If unsure, say N.

config SEQ_BUF_KUNIT_TEST
	tristate "KUnit test for seq_buf" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds unit tests for the seq_buf library.

	  If unsure, say N.

config STRING_KUNIT_TEST
	tristate "KUnit test string functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS

config STRING_HELPERS_KUNIT_TEST
	tristate "KUnit test string helpers at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS

config TEST_KSTRTOX
	tristate "Test kstrto*() family of functions at runtime"

config TEST_BITMAP
	tristate "Test bitmap_*() family of functions at runtime"
	help
	  Enable this option to test the bitmap functions at boot.

	  If unsure, say N.

config TEST_UUID
	tristate "Test functions located in the uuid module at runtime"

config TEST_XARRAY
	tristate "Test the XArray code at runtime"

config TEST_MAPLE_TREE
	tristate "Test the Maple Tree code at runtime or module load"
	help
	  Enable this option to test the maple tree code functions at boot, or
	  when the module is loaded. Enable "Debug Maple Trees" will enable
	  more verbose output on failures.

	  If unsure, say N.

config TEST_RHASHTABLE
	tristate "Perform selftest on resizable hash table"
	help
	  Enable this option to test the rhashtable functions at boot.

	  If unsure, say N.

config TEST_IDA
	tristate "Perform selftest on IDA functions"

config TEST_MISC_MINOR
	bool "miscdevice KUnit test" if !KUNIT_ALL_TESTS
	depends on KUNIT=y
	default KUNIT_ALL_TESTS
	help
	  Kunit test for miscdevice API, specially its behavior in respect to
	  static and dynamic minor numbers.

	  KUnit tests run during boot and output the results to the debug log
	  in TAP format (https://testanything.org/). Only useful for kernel devs
	  running the KUnit test harness, and not intended for inclusion into a
	  production build.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config TEST_PARMAN
	tristate "Perform selftest on priority array manager"
	depends on PARMAN
	help
	  Enable this option to test priority array manager on boot
	  (or module load).

	  If unsure, say N.

config TEST_IRQ_TIMINGS
	bool "IRQ timings selftest"
	depends on IRQ_TIMINGS
	help
	  Enable this option to test the irq timings code on boot.

	  If unsure, say N.

config TEST_LKM
	tristate "Test module loading with 'hello world' module"
	depends on m
	help
	  This builds the "test_module" module that emits "Hello, world"
	  on printk when loaded. It is designed to be used for basic
	  evaluation of the module loading subsystem (for example when
	  validating module verification). It lacks any extra dependencies,
	  and will not normally be loaded by the system unless explicitly
	  requested by name.

	  If unsure, say N.

config TEST_BITOPS
	tristate "Test module for compilation of bitops operations"
	help
	  This builds the "test_bitops" module that is much like the
	  TEST_LKM module except that it does a basic exercise of the
	  set/clear_bit macros and get_count_order/long to make sure there are
	  no compiler warnings from C=1 sparse checker or -Wextra
	  compilations. It has no dependencies and doesn't run or load unless
	  explicitly requested by name.  for example: modprobe test_bitops.

	  If unsure, say N.

config TEST_VMALLOC
	tristate "Test module for stress/performance analysis of vmalloc allocator"
	default n
	depends on MMU
	help
	  This builds the "test_vmalloc" module that should be used for
	  stress and performance analysis. So, any new change for vmalloc
	  subsystem can be evaluated from performance and stability point
	  of view.

	  If unsure, say N.

config TEST_BPF
	tristate "Test BPF filter functionality"
	depends on m && NET
	help
	  This builds the "test_bpf" module that runs various test vectors
	  against the BPF interpreter or BPF JIT compiler depending on the
	  current setting. This is in particular useful for BPF JIT compiler
	  development, but also to run regression tests against changes in
	  the interpreter code. It also enables test stubs for eBPF maps and
	  verifier used by user space verifier testsuite.

	  If unsure, say N.

config FIND_BIT_BENCHMARK
	tristate "Test find_bit functions"
	help
	  This builds the "test_find_bit" module that measure find_*_bit()
	  functions performance.

	  If unsure, say N.

config TEST_FIRMWARE
	tristate "Test firmware loading via userspace interface"
	depends on FW_LOADER
	help
	  This builds the "test_firmware" module that creates a userspace
	  interface for testing firmware loading. This can be used to
	  control the triggering of firmware loading without needing an
	  actual firmware-using device. The contents can be rechecked by
	  userspace.

	  If unsure, say N.

config TEST_SYSCTL
	tristate "sysctl test driver"
	depends on PROC_SYSCTL
	help
	  This builds the "test_sysctl" module. This driver enables to test the
	  proc sysctl interfaces available to drivers safely without affecting
	  production knobs which might alter system functionality.

	  If unsure, say N.

config BITFIELD_KUNIT
	tristate "KUnit test bitfield functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this option to test the bitfield functions at boot.

	  KUnit tests run during boot and output the results to the debug log
	  in TAP format (http://testanything.org/). Only useful for kernel devs
	  running the KUnit test harness, and not intended for inclusion into a
	  production build.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config CHECKSUM_KUNIT
	tristate "KUnit test checksum functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this option to test the checksum functions at boot.

	  KUnit tests run during boot and output the results to the debug log
	  in TAP format (http://testanything.org/). Only useful for kernel devs
	  running the KUnit test harness, and not intended for inclusion into a
	  production build.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config UTIL_MACROS_KUNIT
	tristate "KUnit test util_macros.h functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this option to test the util_macros.h function at boot.

	  KUnit tests run during boot and output the results to the debug log
	  in TAP format (http://testanything.org/). Only useful for kernel devs
	  running the KUnit test harness, and not intended for inclusion into a
	  production build.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config HASH_KUNIT_TEST
	tristate "KUnit Test for integer hash functions" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this option to test the kernel's string (<linux/stringhash.h>), and
	  integer (<linux/hash.h>) hash functions on boot.

	  KUnit tests run during boot and output the results to the debug log
	  in TAP format (https://testanything.org/). Only useful for kernel devs
	  running the KUnit test harness, and not intended for inclusion into a
	  production build.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  This is intended to help people writing architecture-specific
	  optimized versions. If unsure, say N.

config RESOURCE_KUNIT_TEST
	tristate "KUnit test for resource API" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	select GET_FREE_REGION
	help
	  This builds the resource API unit test.
	  Tests the logic of API provided by resource.c and ioport.h.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config SYSCTL_KUNIT_TEST
	tristate "KUnit test for sysctl" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the proc sysctl unit test, which runs on boot.
	  Tests the API contract and implementation correctness of sysctl.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config KFIFO_KUNIT_TEST
	tristate "KUnit Test for the generic kernel FIFO implementation" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the generic FIFO implementation KUnit test suite.
	  It tests that the API and basic functionality of the kfifo type
	  and associated macros.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config LIST_KUNIT_TEST
	tristate "KUnit Test for Kernel Linked-list structures" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the linked list KUnit test suite.
	  It tests that the API and basic functionality of the list_head type
	  and associated macros.

	  KUnit tests run during boot and output the results to the debug log
	  in TAP format (https://testanything.org/). Only useful for kernel devs
	  running the KUnit test harness, and not intended for inclusion into a
	  production build.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config HASHTABLE_KUNIT_TEST
	tristate "KUnit Test for Kernel Hashtable structures" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the hashtable KUnit test suite.
	  It tests the basic functionality of the API defined in
	  include/linux/hashtable.h. For more information on KUnit and
	  unit tests in general please refer to the KUnit documentation
	  in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config LINEAR_RANGES_TEST
	tristate "KUnit test for linear_ranges"
	depends on KUNIT
	select LINEAR_RANGES
	help
	  This builds the linear_ranges unit test, which runs on boot.
	  Tests the linear_ranges logic correctness.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config CMDLINE_KUNIT_TEST
	tristate "KUnit test for cmdline API" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the cmdline API unit test.
	  Tests the logic of API provided by cmdline.c.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config BITS_TEST
	tristate "KUnit test for bits.h" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the bits unit test.
	  Tests the logic of macros defined in bits.h.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config SLUB_KUNIT_TEST
	tristate "KUnit test for SLUB cache error detection" if !KUNIT_ALL_TESTS
	depends on SLUB_DEBUG && KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds SLUB allocator unit test.
	  Tests SLUB cache debugging functionality.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config RATIONAL_KUNIT_TEST
	tristate "KUnit test for rational.c" if !KUNIT_ALL_TESTS
	depends on KUNIT && RATIONAL
	default KUNIT_ALL_TESTS
	help
	  This builds the rational math unit test.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config MEMCPY_KUNIT_TEST
	tristate "Test memcpy(), memmove(), and memset() functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Builds unit tests for memcpy(), memmove(), and memset() functions.
	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config IS_SIGNED_TYPE_KUNIT_TEST
	tristate "Test is_signed_type() macro" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Builds unit tests for the is_signed_type() macro.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config OVERFLOW_KUNIT_TEST
	tristate "Test check_*_overflow() functions at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Builds unit tests for the check_*_overflow(), size_*(), allocation, and
	  related functions.

	  For more information on KUnit and unit tests in general please refer
	  to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

config RANDSTRUCT_KUNIT_TEST
	tristate "Test randstruct structure layout randomization at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Builds unit tests for the checking CONFIG_RANDSTRUCT=y, which
	  randomizes structure layouts.

config STACKINIT_KUNIT_TEST
	tristate "Test level of stack variable initialization" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Test if the kernel is zero-initializing stack variables and
	  padding. Coverage is controlled by compiler flags,
	  CONFIG_INIT_STACK_ALL_PATTERN or CONFIG_INIT_STACK_ALL_ZERO.

config FORTIFY_KUNIT_TEST
	tristate "Test fortified str*() and mem*() function internals at runtime" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Builds unit tests for checking internals of FORTIFY_SOURCE as used
	  by the str*() and mem*() family of functions. For testing runtime
	  traps of FORTIFY_SOURCE, see LKDTM's "FORTIFY_*" tests.

config LONGEST_SYM_KUNIT_TEST
	tristate "Test the longest symbol possible" if !KUNIT_ALL_TESTS
	depends on KUNIT && KPROBES
	depends on !PREFIX_SYMBOLS && !CFI_CLANG && !GCOV_KERNEL
	default KUNIT_ALL_TESTS
	help
	  Tests the longest symbol possible

	  If unsure, say N.

config HW_BREAKPOINT_KUNIT_TEST
	bool "Test hw_breakpoint constraints accounting" if !KUNIT_ALL_TESTS
	depends on HAVE_HW_BREAKPOINT
	depends on KUNIT=y
	default KUNIT_ALL_TESTS
	help
	  Tests for hw_breakpoint constraints accounting.

	  If unsure, say N.

config SIPHASH_KUNIT_TEST
	tristate "Perform selftest on siphash functions" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  Enable this option to test the kernel's siphash (<linux/siphash.h>) hash
	  functions on boot (or module load).

	  This is intended to help people writing architecture-specific
	  optimized versions.  If unsure, say N.

config USERCOPY_KUNIT_TEST
	tristate "KUnit Test for user/kernel boundary protections"
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the "usercopy_kunit" module that runs sanity checks
	  on the copy_to/from_user infrastructure, making sure basic
	  user/kernel boundary testing is working.

config BLACKHOLE_DEV_KUNIT_TEST
	tristate "Test blackhole netdev functionality" if !KUNIT_ALL_TESTS
	depends on NET
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the "blackhole_dev_kunit" module that validates the
	  data path through this blackhole netdev.

	  If unsure, say N.

config TEST_UDELAY
	tristate "udelay test driver"
	help
	  This builds the "udelay_test" module that helps to make sure
	  that udelay() is working properly.

	  If unsure, say N.

config TEST_STATIC_KEYS
	tristate "Test static keys"
	depends on m
	help
	  Test the static key interfaces.

	  If unsure, say N.

config TEST_DYNAMIC_DEBUG
	tristate "Test DYNAMIC_DEBUG"
	depends on DYNAMIC_DEBUG
	help
	  This module registers a tracer callback to count enabled
	  pr_debugs in a 'do_debugging' function, then alters their
	  enablements, calls the function, and compares counts.

	  If unsure, say N.

config TEST_KMOD
	tristate "kmod stress tester"
	depends on m
	select TEST_LKM
	help
	  Test the kernel's module loading mechanism: kmod. kmod implements
	  support to load modules using the Linux kernel's usermode helper.
	  This test provides a series of tests against kmod.

	  Although technically you can either build test_kmod as a module or
	  into the kernel we disallow building it into the kernel since
	  it stress tests request_module() and this will very likely cause
	  some issues by taking over precious threads available from other
	  module load requests, ultimately this could be fatal.

	  To run tests run:

	  tools/testing/selftests/kmod/kmod.sh --help

	  If unsure, say N.

config TEST_RUNTIME
	bool

config TEST_RUNTIME_MODULE
	bool

config TEST_KALLSYMS
	tristate "module kallsyms find_symbol() test"
	depends on m
	select TEST_RUNTIME
	select TEST_RUNTIME_MODULE
	select TEST_KALLSYMS_A
	select TEST_KALLSYMS_B
	select TEST_KALLSYMS_C
	select TEST_KALLSYMS_D
	help
	  This allows us to stress test find_symbol() through the kallsyms
	  used to place symbols on the kernel ELF kallsyms and modules kallsyms
	  where we place kernel symbols such as exported symbols.

	  We have four test modules:

	  A: has KALLSYSMS_NUMSYMS exported symbols
	  B: uses one of A's symbols
	  C: adds KALLSYMS_SCALE_FACTOR * KALLSYSMS_NUMSYMS exported
	  D: adds 2 * the symbols than C

	  We stress test find_symbol() through two means:

	  1) Upon load of B it will trigger simplify_symbols() to look for the
	  one symbol it uses from the module A with tons of symbols. This is an
	  indirect way for us to have B call resolve_symbol_wait() upon module
	  load. This will eventually call find_symbol() which will eventually
	  try to find the symbols used with find_exported_symbol_in_section().
	  find_exported_symbol_in_section() uses bsearch() so a binary search
	  for each symbol. Binary search will at worst be O(log(n)) so the
	  larger TEST_MODULE_KALLSYSMS the worse the search.

	  2) The selftests should load C first, before B. Upon B's load towards
	  the end right before we call module B's init routine we get
	  complete_formation() called on the module. That will first check
	  for duplicate symbols with the call to verify_exported_symbols().
	  That is when we'll force iteration on module C's insane symbol list.
	  Since it has 10 * KALLSYMS_NUMSYMS it means we can first test
	  just loading B without C. The amount of time it takes to load C Vs
	  B can give us an idea of the impact growth of the symbol space and
	  give us projection. Module A only uses one symbol from B so to allow
	  this scaling in module C to be proportional, if it used more symbols
	  then the first test would be doing more and increasing just the
	  search space would be slightly different. The last module, module D
	  will just increase the search space by twice the number of symbols in
	  C so to allow for full projects.

	  tools/testing/selftests/module/find_symbol.sh

	  The current defaults will incur a build delay of about 7 minutes
	  on an x86_64 with only 8 cores. Enable this only if you want to
	  stress test find_symbol() with thousands of symbols. At the same
	  time this is also useful to test building modules with thousands of
	  symbols, and if BTF is enabled this also stress tests adding BTF
	  information for each module. Currently enabling many more symbols
	  will segfault the build system.

	  If unsure, say N.

if TEST_KALLSYMS

config TEST_KALLSYMS_A
	tristate
	depends on m

config TEST_KALLSYMS_B
	tristate
	depends on m

config TEST_KALLSYMS_C
	tristate
	depends on m

config TEST_KALLSYMS_D
	tristate
	depends on m

choice
	prompt "Kallsym test range"
	default TEST_KALLSYMS_LARGE
	help
	  Selecting something other than "Fast" will enable tests which slow
	  down the build and may crash your build.

config TEST_KALLSYMS_FAST
	bool "Fast builds"
	help
	  You won't really be testing kallsysms, so this just helps fast builds
	  when allmodconfig is used..

config TEST_KALLSYMS_LARGE
	bool "Enable testing kallsyms with large exports"
	help
	  This will enable larger number of symbols. This will slow down
	  your build considerably.

config TEST_KALLSYMS_MAX
	bool "Known kallsysms limits"
	help
	  This will enable exports to the point we know we'll start crashing
	  builds.

endchoice

config TEST_KALLSYMS_NUMSYMS
	int "test kallsyms number of symbols"
	range 2 10000
	default 2 if TEST_KALLSYMS_FAST
	default 100 if TEST_KALLSYMS_LARGE
	default 10000 if TEST_KALLSYMS_MAX
	help
	  The number of symbols to create on TEST_KALLSYMS_A, only one of which
	  module TEST_KALLSYMS_B will use. This also will be used
	  for how many symbols TEST_KALLSYMS_C will have, scaled up by
	  TEST_KALLSYMS_SCALE_FACTOR. Note that setting this to 10,000 will
	  trigger a segfault today, don't use anything close to it unless
	  you are aware that this should not be used for automated build tests.

config TEST_KALLSYMS_SCALE_FACTOR
	int "test kallsyms scale factor"
	default 8
	help
	  How many more unusued symbols will TEST_KALLSYSMS_C have than
	  TEST_KALLSYMS_A. If 8, then module C will have 8 * syms
	  than module A. Then TEST_KALLSYMS_D will have double the amount
	  of symbols than C so to allow projections.

endif # TEST_KALLSYMS

config TEST_DEBUG_VIRTUAL
	tristate "Test CONFIG_DEBUG_VIRTUAL feature"
	depends on DEBUG_VIRTUAL
	help
	  Test the kernel's ability to detect incorrect calls to
	  virt_to_phys() done against the non-linear part of the
	  kernel's virtual address map.

	  If unsure, say N.

config TEST_MEMCAT_P
	tristate "Test memcat_p() helper function"
	help
	  Test the memcat_p() helper for correctly merging two
	  pointer arrays together.

	  If unsure, say N.

config TEST_OBJAGG
	tristate "Perform selftest on object aggreration manager"
	default n
	depends on OBJAGG
	help
	  Enable this option to test object aggregation manager on boot
	  (or module load).

config TEST_MEMINIT
	tristate "Test heap/page initialization"
	help
	  Test if the kernel is zero-initializing heap and page allocations.
	  This can be useful to test init_on_alloc and init_on_free features.

	  If unsure, say N.

config TEST_HMM
	tristate "Test HMM (Heterogeneous Memory Management)"
	depends on TRANSPARENT_HUGEPAGE
	depends on DEVICE_PRIVATE
	select HMM_MIRROR
	select MMU_NOTIFIER
	help
	  This is a pseudo device driver solely for testing HMM.
	  Say M here if you want to build the HMM test module.
	  Doing so will allow you to run tools/testing/selftest/vm/hmm-tests.

	  If unsure, say N.

config TEST_FREE_PAGES
	tristate "Test freeing pages"
	help
	  Test that a memory leak does not occur due to a race between
	  freeing a block of pages and a speculative page reference.
	  Loading this module is safe if your kernel has the bug fixed.
	  If the bug is not fixed, it will leak gigabytes of memory and
	  probably OOM your system.

config TEST_FPU
	tristate "Test floating point operations in kernel space"
	depends on ARCH_HAS_KERNEL_FPU_SUPPORT && !KCOV_INSTRUMENT_ALL
	help
	  Enable this option to add /sys/kernel/debug/selftest_helpers/test_fpu
	  which will trigger a sequence of floating point operations. This is used
	  for self-testing floating point control register setting in
	  kernel_fpu_begin().

	  If unsure, say N.

config TEST_CLOCKSOURCE_WATCHDOG
	tristate "Test clocksource watchdog in kernel space"
	depends on CLOCKSOURCE_WATCHDOG
	help
	  Enable this option to create a kernel module that will trigger
	  a test of the clocksource watchdog.  This module may be loaded
	  via modprobe or insmod in which case it will run upon being
	  loaded, or it may be built in, in which case it will run
	  shortly after boot.

	  If unsure, say N.

config TEST_OBJPOOL
	tristate "Test module for correctness and stress of objpool"
	default n
	depends on m && DEBUG_KERNEL
	help
	  This builds the "test_objpool" module that should be used for
	  correctness verification and concurrent testings of objects
	  allocation and reclamation.

	  If unsure, say N.

config TEST_KEXEC_HANDOVER
	bool "Test for Kexec HandOver"
	default n
	depends on KEXEC_HANDOVER
	help
	  This option enables test for Kexec HandOver (KHO).
	  The test consists of two parts: saving kernel data before kexec and
	  restoring the data after kexec and verifying that it was properly
	  handed over. This test module creates and saves data on the boot of
	  the first kernel and restores and verifies the data on the boot of
	  kexec'ed kernel.

	  For detailed documentation about KHO, see Documentation/core-api/kho.

	  To run the test run:

	  tools/testing/selftests/kho/vmtest.sh -h

	  If unsure, say N.

config RATELIMIT_KUNIT_TEST
	tristate "KUnit Test for correctness and stress of ratelimit" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This builds the "test_ratelimit" module that should be used
	  for correctness verification and concurrent testings of rate
	  limiting.

	  If unsure, say N.

config INT_POW_KUNIT_TEST
	tristate "Integer exponentiation (int_pow) test" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This option enables the KUnit test suite for the int_pow function,
	  which performs integer exponentiation. The test suite is designed to
	  verify that the implementation of int_pow correctly computes the power
	  of a given base raised to a given exponent.

	  Enabling this option will include tests that check various scenarios
	  and edge cases to ensure the accuracy and reliability of the exponentiation
	  function.

	  If unsure, say N

config INT_SQRT_KUNIT_TEST
	tristate "Integer square root test" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This option enables the KUnit test suite for the int_sqrt() function,
	  which performs square root calculation. The test suite checks
	  various scenarios, including edge cases, to ensure correctness.

	  Enabling this option will include tests that check various scenarios
	  and edge cases to ensure the accuracy and reliability of the square root
	  function.

	  If unsure, say N

config INT_LOG_KUNIT_TEST
        tristate "Integer log (int_log) test" if !KUNIT_ALL_TESTS
        depends on KUNIT
        default KUNIT_ALL_TESTS
        help
          This option enables the KUnit test suite for the int_log library, which
          provides two functions to compute the integer logarithm in base 2 and
          base 10, called respectively as intlog2 and intlog10.

          If unsure, say N

config GCD_KUNIT_TEST
	tristate "Greatest common divisor test" if !KUNIT_ALL_TESTS
	depends on KUNIT
	default KUNIT_ALL_TESTS
	help
	  This option enables the KUnit test suite for the gcd() function,
	  which computes the greatest common divisor of two numbers.

	  This test suite verifies the correctness of gcd() across various
	  scenarios, including edge cases.

	  If unsure, say N

config PRIME_NUMBERS_KUNIT_TEST
	tristate "Prime number generator test" if !KUNIT_ALL_TESTS
	depends on KUNIT
	depends on PRIME_NUMBERS
	default KUNIT_ALL_TESTS
	help
	  This option enables the KUnit test suite for the {is,next}_prime_number
	  functions.

	  Enabling this option will include tests that compare the prime number
	  generator functions against a brute force implementation.

	  If unsure, say N

endif # RUNTIME_TESTING_MENU

config ARCH_USE_MEMTEST
	bool
	help
	  An architecture should select this when it uses early_memtest()
	  during boot process.

config MEMTEST
	bool "Memtest"
	depends on ARCH_USE_MEMTEST
	help
	  This option adds a kernel parameter 'memtest', which allows memtest
	  to be set and executed.
	        memtest=0, mean disabled; -- default
	        memtest=1, mean do 1 test pattern;
	        ...
	        memtest=17, mean do 17 test patterns.
	  If you are unsure how to answer this question, answer N.



config HYPERV_TESTING
	bool "Microsoft Hyper-V driver testing"
	default n
	depends on HYPERV && DEBUG_FS
	help
	  Select this option to enable Hyper-V vmbus testing.

endmenu # "Kernel Testing and Coverage"

menu "Rust hacking"

config RUST_DEBUG_ASSERTIONS
	bool "Debug assertions"
	depends on RUST
	help
	  Enables rustc's `-Cdebug-assertions` codegen option.

	  This flag lets you turn `cfg(debug_assertions)` conditional
	  compilation on or off. This can be used to enable extra debugging
	  code in development but not in production. For example, it controls
	  the behavior of the standard library's `debug_assert!` macro.

	  Note that this will apply to all Rust code, including `core`.

	  If unsure, say N.

config RUST_OVERFLOW_CHECKS
	bool "Overflow checks"
	default y
	depends on RUST
	help
	  Enables rustc's `-Coverflow-checks` codegen option.

	  This flag allows you to control the behavior of runtime integer
	  overflow. When overflow-checks are enabled, a Rust panic will occur
	  on overflow.

	  Note that this will apply to all Rust code, including `core`.

	  If unsure, say Y.

config RUST_BUILD_ASSERT_ALLOW
	bool "Allow unoptimized build-time assertions"
	depends on RUST
	help
	  Controls how `build_error!` and `build_assert!` are handled during the build.

	  If calls to them exist in the binary, it may indicate a violated invariant
	  or that the optimizer failed to verify the invariant during compilation.

	  This should not happen, thus by default the build is aborted. However,
	  as an escape hatch, you can choose Y here to ignore them during build
	  and let the check be carried at runtime (with `panic!` being called if
	  the check fails).

	  If unsure, say N.

config RUST_KERNEL_DOCTESTS
	bool "Doctests for the `kernel` crate" if !KUNIT_ALL_TESTS
	depends on RUST && KUNIT=y
	default KUNIT_ALL_TESTS
	help
	  This builds the documentation tests of the `kernel` crate
	  as KUnit tests.

	  For more information on KUnit and unit tests in general,
	  please refer to the KUnit documentation in Documentation/dev-tools/kunit/.

	  If unsure, say N.

endmenu # "Rust"

endmenu # Kernel hacking
